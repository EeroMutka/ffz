// sooo... the checker is allowed to encounter polymorphic definitions and instantiations.
// But when instantiating, it starts to copy the polymorphic definition into its own branch.

// When the checker is done, you have an expanded tree with no polymorphism. This tree
// is also valid a FFZ tree (can be converted back to text and fed back to the checker)



#foo: poly[X] proc => int {
	a: 5 + X
	ret a
}


#bar: proc {
	
	#my_value: 500
	
	// the problem is, you can't just move a constant definition into its outer scope.
	#my_proc: proc(x: int) {
		y: my_value
		dbgbreak
	}
	
	x: foo[1 + 5]()
	y: foo[my_proc]()
	
}

// in order to deduplicate polymorphic definitions the best, we should place them at the global scope.

// we could just say for now "Unless all of your constants are global,
// the tree won't be valid when serialized back to text, as the binary form
// holds invisible references to local constant definitions".

// hmm... the nice thing about being able to convert back is that if you have some metaprogram that
// makes modifications to the tree, it'd be trivial to print it and debug the modified tree in a debugger.

// I feel like the best idea is to start out by not supporting local constants, and as the next step
// support accessing local values from outside, and make the deep copy operation automatically convert
// identifiers to accessor-paths.

// The ACTUAL functionality we want is to be able to convert from constant -> printable AST.
// FFZ constant, when procedure, stores a pointer to the procedure node.

#foo___polyid_1: proc => int {
	#T: 6
	a: T(50)
	ret a
}

#foo___polyid_2: proc => int {
	#T: proc(x: int) {
		y: bar.my_value
		dbgbreak
	}
	a: T(50)
	ret a
}


