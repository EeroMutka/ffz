// This file was generated by library_translator.

#Vector2: struct {
	x: f32
	y: f32
}

#Vector3: struct {
	x: f32
	y: f32
	z: f32
}

#Vector4: struct {
	x: f32
	y: f32
	z: f32
	w: f32
}

#Quaternion: struct {
	x: f32
	y: f32
	z: f32
	w: f32
}

#Matrix: struct {
	m0: f32
	m4: f32
	m8: f32
	m12: f32
	m1: f32
	m5: f32
	m9: f32
	m13: f32
	m2: f32
	m6: f32
	m10: f32
	m14: f32
	m3: f32
	m7: f32
	m11: f32
	m15: f32
}

#Color: struct {
	r: u8
	g: u8
	b: u8
	a: u8
}

#Rectangle: struct {
	x: f32
	y: f32
	width: f32
	height: f32
}

#Image: struct {
	data: ^u8
	width: s32
	height: s32
	mipmaps: s32
	format: s32
}

#Texture: struct {
	id: u32
	width: s32
	height: s32
	mipmaps: s32
	format: s32
}

#Texture2D: struct {
	id: u32
	width: s32
	height: s32
	mipmaps: s32
	format: s32
}

#TextureCubemap: struct {
	id: u32
	width: s32
	height: s32
	mipmaps: s32
	format: s32
}

#RenderTexture: struct {
	id: u32
	texture: Texture
	depth: Texture
}

#RenderTexture2D: struct {
	id: u32
	texture: Texture
	depth: Texture
}

#NPatchInfo: struct {
	source: Rectangle
	left: s32
	top: s32
	right: s32
	bottom: s32
	layout: s32
}

#GlyphInfo: struct {
	value: s32
	offsetX: s32
	offsetY: s32
	advanceX: s32
	image: Image
}

#Font: struct {
	baseSize: s32
	glyphCount: s32
	glyphPadding: s32
	texture: Texture2D
	recs: ^Rectangle
	glyphs: ^GlyphInfo
}

#Camera3D: struct {
	position: Vector3
	target: Vector3
	up: Vector3
	fovy: f32
	projection: s32
}

#Camera: struct {
	position: Vector3
	target: Vector3
	up: Vector3
	fovy: f32
	projection: s32
}

#Camera2D: struct {
	offset: Vector2
	target: Vector2
	rotation: f32
	zoom: f32
}

#Mesh: struct {
	vertexCount: s32
	triangleCount: s32
	vertices: ^f32
	texcoords: ^f32
	texcoords2: ^f32
	normals: ^f32
	tangents: ^f32
	colors: ^u8
	indices: ^u16
	animVertices: ^f32
	animNormals: ^f32
	boneIds: ^u8
	boneWeights: ^f32
	vaoId: u32
	vboId: ^u32
}

#Shader: struct {
	id: u32
	locs: ^s32
}

#MaterialMap: struct {
	texture: Texture2D
	color: Color
	value: f32
}

#Material: struct {
	shader: Shader
	maps: ^MaterialMap
	params: [4]f32
}

#Transform: struct {
	translation: Vector3
	rotation: Quaternion
	scale: Vector3
}

#BoneInfo: struct {
	name: [32]u8
	parent: s32
}

#Model: struct {
	transform: Matrix
	meshCount: s32
	materialCount: s32
	meshes: ^Mesh
	materials: ^Material
	meshMaterial: ^s32
	boneCount: s32
	bones: ^BoneInfo
	bindPose: ^Transform
}

#ModelAnimation: struct {
	boneCount: s32
	frameCount: s32
	bones: ^BoneInfo
	framePoses: ^^Transform
}

#Ray: struct {
	position: Vector3
	direction: Vector3
}

#RayCollision: struct {
	hit: bool
	distance: f32
	point: Vector3
	normal: Vector3
}

#BoundingBox: struct {
	min: Vector3
	max: Vector3
}

#Wave: struct {
	frameCount: u32
	sampleRate: u32
	sampleSize: u32
	channels: u32
	data: ^u8
}

#rAudioBuffer: struct {
}

#rAudioProcessor: struct {
}

#AudioStream: struct {
	buffer: ^rAudioBuffer
	processor: ^rAudioProcessor
	sampleRate: u32
	sampleSize: u32
	channels: u32
}

#Sound: struct {
	stream: AudioStream
	frameCount: u32
}

#Music: struct {
	stream: AudioStream
	frameCount: u32
	looping: bool
	ctxType: s32
	ctxData: ^u8
}

#VrDeviceInfo: struct {
	hResolution: s32
	vResolution: s32
	hScreenSize: f32
	vScreenSize: f32
	vScreenCenter: f32
	eyeToScreenDistance: f32
	lensSeparationDistance: f32
	interpupillaryDistance: f32
	lensDistortionValues: [4]f32
	chromaAbCorrection: [4]f32
}

#VrStereoConfig: struct {
	projection: [2]Matrix
	viewOffset: [2]Matrix
	leftLensCenter: [2]f32
	rightLensCenter: [2]f32
	leftScreenCenter: [2]f32
	rightScreenCenter: [2]f32
	scale: [2]f32
	scaleIn: [2]f32
}

#FilePathList: struct {
	capacity: u32
	count: u32
	paths: ^^u8
}

#ConfigFlags: enum, u32 {
	VSYNC_HINT: 64
	FULLSCREEN_MODE: 2
	WINDOW_RESIZABLE: 4
	WINDOW_UNDECORATED: 8
	WINDOW_HIDDEN: 128
	WINDOW_MINIMIZED: 512
	WINDOW_MAXIMIZED: 1024
	WINDOW_UNFOCUSED: 2048
	WINDOW_TOPMOST: 4096
	WINDOW_ALWAYS_RUN: 256
	WINDOW_TRANSPARENT: 16
	WINDOW_HIGHDPI: 8192
	WINDOW_MOUSE_PASSTHROUGH: 16384
	MSAA_4X_HINT: 32
	INTERLACED_HINT: 65536
}

#TraceLogLevel: enum, u32 {
	ALL: 0
	TRACE: 1
	DEBUG: 2
	INFO: 3
	WARNING: 4
	ERROR: 5
	FATAL: 6
	NONE: 7
}

#KeyboardKey: enum, u32 {
	NULL: 0
	APOSTROPHE: 39
	COMMA: 44
	MINUS: 45
	PERIOD: 46
	SLASH: 47
	ZERO: 48
	ONE: 49
	TWO: 50
	THREE: 51
	FOUR: 52
	FIVE: 53
	SIX: 54
	SEVEN: 55
	EIGHT: 56
	NINE: 57
	SEMICOLON: 59
	EQUAL: 61
	A: 65
	B: 66
	C: 67
	D: 68
	E: 69
	F: 70
	G: 71
	H: 72
	I: 73
	J: 74
	K: 75
	L: 76
	M: 77
	N: 78
	O: 79
	P: 80
	Q: 81
	R: 82
	S: 83
	T: 84
	U: 85
	V: 86
	W: 87
	X: 88
	Y: 89
	Z: 90
	LEFT_BRACKET: 91
	BACKSLASH: 92
	RIGHT_BRACKET: 93
	GRAVE: 96
	SPACE: 32
	ESCAPE: 256
	ENTER: 257
	TAB: 258
	BACKSPACE: 259
	INSERT: 260
	DELETE: 261
	RIGHT: 262
	LEFT: 263
	DOWN: 264
	UP: 265
	PAGE_UP: 266
	PAGE_DOWN: 267
	HOME: 268
	END: 269
	CAPS_LOCK: 280
	SCROLL_LOCK: 281
	NUM_LOCK: 282
	PRINT_SCREEN: 283
	PAUSE: 284
	F1: 290
	F2: 291
	F3: 292
	F4: 293
	F5: 294
	F6: 295
	F7: 296
	F8: 297
	F9: 298
	F10: 299
	F11: 300
	F12: 301
	LEFT_SHIFT: 340
	LEFT_CONTROL: 341
	LEFT_ALT: 342
	LEFT_SUPER: 343
	RIGHT_SHIFT: 344
	RIGHT_CONTROL: 345
	RIGHT_ALT: 346
	RIGHT_SUPER: 347
	KB_MENU: 348
	KP_0: 320
	KP_1: 321
	KP_2: 322
	KP_3: 323
	KP_4: 324
	KP_5: 325
	KP_6: 326
	KP_7: 327
	KP_8: 328
	KP_9: 329
	KP_DECIMAL: 330
	KP_DIVIDE: 331
	KP_MULTIPLY: 332
	KP_SUBTRACT: 333
	KP_ADD: 334
	KP_ENTER: 335
	KP_EQUAL: 336
/* hmm... ffz currently doesn't allow for shared enum values.
	BACK: 4
	MENU: 82
	VOLUME_UP: 24
	VOLUME_DOWN: 25
 */
}

#MouseButton: enum, u32 {
	LEFT: 0
	RIGHT: 1
	MIDDLE: 2
	SIDE: 3
	EXTRA: 4
	FORWARD: 5
	BACK: 6
}

#MouseCursor: enum, u32 {
	DEFAULT: 0
	ARROW: 1
	IBEAM: 2
	CROSSHAIR: 3
	POINTING_HAND: 4
	RESIZE_EW: 5
	RESIZE_NS: 6
	RESIZE_NWSE: 7
	RESIZE_NESW: 8
	RESIZE_ALL: 9
	NOT_ALLOWED: 10
}

#GamepadButton: enum, u32 {
	UNKNOWN: 0
	LEFT_FACE_UP: 1
	LEFT_FACE_RIGHT: 2
	LEFT_FACE_DOWN: 3
	LEFT_FACE_LEFT: 4
	RIGHT_FACE_UP: 5
	RIGHT_FACE_RIGHT: 6
	RIGHT_FACE_DOWN: 7
	RIGHT_FACE_LEFT: 8
	LEFT_TRIGGER_1: 9
	LEFT_TRIGGER_2: 10
	RIGHT_TRIGGER_1: 11
	RIGHT_TRIGGER_2: 12
	MIDDLE_LEFT: 13
	MIDDLE: 14
	MIDDLE_RIGHT: 15
	LEFT_THUMB: 16
	RIGHT_THUMB: 17
}

#GamepadAxis: enum, u32 {
	LEFT_X: 0
	LEFT_Y: 1
	RIGHT_X: 2
	RIGHT_Y: 3
	LEFT_TRIGGER: 4
	RIGHT_TRIGGER: 5
}

#MaterialMapIndex: enum, u32 {
	ALBEDO: 0
	METALNESS: 1
	NORMAL: 2
	ROUGHNESS: 3
	OCCLUSION: 4
	EMISSION: 5
	HEIGHT: 6
	CUBEMAP: 7
	IRRADIANCE: 8
	PREFILTER: 9
	BRDF: 10
}

#ShaderLocationIndex: enum, u32 {
	VERTEX_POSITION: 0
	VERTEX_TEXCOORD01: 1
	VERTEX_TEXCOORD02: 2
	VERTEX_NORMAL: 3
	VERTEX_TANGENT: 4
	VERTEX_COLOR: 5
	MATRIX_MVP: 6
	MATRIX_VIEW: 7
	MATRIX_PROJECTION: 8
	MATRIX_MODEL: 9
	MATRIX_NORMAL: 10
	VECTOR_VIEW: 11
	COLOR_DIFFUSE: 12
	COLOR_SPECULAR: 13
	COLOR_AMBIENT: 14
	MAP_ALBEDO: 15
	MAP_METALNESS: 16
	MAP_NORMAL: 17
	MAP_ROUGHNESS: 18
	MAP_OCCLUSION: 19
	MAP_EMISSION: 20
	MAP_HEIGHT: 21
	MAP_CUBEMAP: 22
	MAP_IRRADIANCE: 23
	MAP_PREFILTER: 24
	MAP_BRDF: 25
}

#ShaderUniformDataType: enum, u32 {
	FLOAT: 0
	VEC2: 1
	VEC3: 2
	VEC4: 3
	INT: 4
	IVEC2: 5
	IVEC3: 6
	IVEC4: 7
	SAMPLER2D: 8
}

#ShaderAttributeDataType: enum, u32 {
	FLOAT: 0
	VEC2: 1
	VEC3: 2
	VEC4: 3
}

#PixelFormat: enum, u32 {
	UNCOMPRESSED_GRAYSCALE: 1
	UNCOMPRESSED_GRAY_ALPHA: 2
	UNCOMPRESSED_R5G6B5: 3
	UNCOMPRESSED_R8G8B8: 4
	UNCOMPRESSED_R5G5B5A1: 5
	UNCOMPRESSED_R4G4B4A4: 6
	UNCOMPRESSED_R8G8B8A8: 7
	UNCOMPRESSED_R32: 8
	UNCOMPRESSED_R32G32B32: 9
	UNCOMPRESSED_R32G32B32A32: 10
	COMPRESSED_DXT1_RGB: 11
	COMPRESSED_DXT1_RGBA: 12
	COMPRESSED_DXT3_RGBA: 13
	COMPRESSED_DXT5_RGBA: 14
	COMPRESSED_ETC1_RGB: 15
	COMPRESSED_ETC2_RGB: 16
	COMPRESSED_ETC2_EAC_RGBA: 17
	COMPRESSED_PVRT_RGB: 18
	COMPRESSED_PVRT_RGBA: 19
	COMPRESSED_ASTC_4x4_RGBA: 20
	COMPRESSED_ASTC_8x8_RGBA: 21
}

#TextureFilter: enum, u32 {
	POINT: 0
	BILINEAR: 1
	TRILINEAR: 2
	ANISOTROPIC_4X: 3
	ANISOTROPIC_8X: 4
	ANISOTROPIC_16X: 5
}

#TextureWrap: enum, u32 {
	REPEAT: 0
	CLAMP: 1
	MIRROR_REPEAT: 2
	MIRROR_CLAMP: 3
}

#CubemapLayout: enum, u32 {
	AUTO_DETECT: 0
	LINE_VERTICAL: 1
	LINE_HORIZONTAL: 2
	CROSS_THREE_BY_FOUR: 3
	CROSS_FOUR_BY_THREE: 4
	PANORAMA: 5
}

#FontType: enum, u32 {
	DEFAULT: 0
	BITMAP: 1
	SDF: 2
}

#BlendMode: enum, u32 {
	ALPHA: 0
	ADDITIVE: 1
	MULTIPLIED: 2
	ADD_COLORS: 3
	SUBTRACT_COLORS: 4
	ALPHA_PREMULTIPLY: 5
	CUSTOM: 6
	CUSTOM_SEPARATE: 7
}

#Gesture: enum, u32 {
	NONE: 0
	TAP: 1
	DOUBLETAP: 2
	HOLD: 4
	DRAG: 8
	SWIPE_RIGHT: 16
	SWIPE_LEFT: 32
	SWIPE_UP: 64
	SWIPE_DOWN: 128
	PINCH_IN: 256
	PINCH_OUT: 512
}

#CameraMode: enum, u32 {
	CUSTOM: 0
	FREE: 1
	ORBITAL: 2
	FIRST_PERSON: 3
	THIRD_PERSON: 4
}

#CameraProjection: enum, u32 {
	PERSPECTIVE: 0
	ORTHOGRAPHIC: 1
}

#NPatchLayout: enum, u32 {
	NINE_PATCH: 0
	THREE_PATCH_VERTICAL: 1
	THREE_PATCH_HORIZONTAL: 2
}

#TraceLogCallback: proc(logLevel: s32, text: ^u8 /*, args: va_list*/)

#LoadFileDataCallback: proc(fileName: ^u8, bytesRead: ^u32) => (^u8)

#SaveFileDataCallback: proc(fileName: ^u8, data: ^u8, bytesToWrite: u32) => (bool)

#LoadFileTextCallback: proc(fileName: ^u8) => (^u8)

#SaveFileTextCallback: proc(fileName: ^u8, text: ^u8) => (bool)

#AudioCallback: proc(bufferData: ^u8, frames: u32)

#InitWindow: @extern proc(width: s32, height: s32, title: ^u8)

#WindowShouldClose: @extern proc => (bool)

#CloseWindow: @extern proc

#IsWindowReady: @extern proc => (bool)

#IsWindowFullscreen: @extern proc => (bool)

#IsWindowHidden: @extern proc => (bool)

#IsWindowMinimized: @extern proc => (bool)

#IsWindowMaximized: @extern proc => (bool)

#IsWindowFocused: @extern proc => (bool)

#IsWindowResized: @extern proc => (bool)

#IsWindowState: @extern proc(flag: u32) => (bool)

#SetWindowState: @extern proc(flags: u32)

#ClearWindowState: @extern proc(flags: u32)

#ToggleFullscreen: @extern proc

#MaximizeWindow: @extern proc

#MinimizeWindow: @extern proc

#RestoreWindow: @extern proc

#SetWindowIcon: @extern proc(image: Image)

#SetWindowTitle: @extern proc(title: ^u8)

#SetWindowPosition: @extern proc(x: s32, y: s32)

#SetWindowMonitor: @extern proc(monitor: s32)

#SetWindowMinSize: @extern proc(width: s32, height: s32)

#SetWindowSize: @extern proc(width: s32, height: s32)

#SetWindowOpacity: @extern proc(opacity: f32)

#GetWindowHandle: @extern proc => (^u8)

#GetScreenWidth: @extern proc => (s32)

#GetScreenHeight: @extern proc => (s32)

#GetRenderWidth: @extern proc => (s32)

#GetRenderHeight: @extern proc => (s32)

#GetMonitorCount: @extern proc => (s32)

#GetCurrentMonitor: @extern proc => (s32)

#GetMonitorPosition: @extern proc(monitor: s32) => (Vector2)

#GetMonitorWidth: @extern proc(monitor: s32) => (s32)

#GetMonitorHeight: @extern proc(monitor: s32) => (s32)

#GetMonitorPhysicalWidth: @extern proc(monitor: s32) => (s32)

#GetMonitorPhysicalHeight: @extern proc(monitor: s32) => (s32)

#GetMonitorRefreshRate: @extern proc(monitor: s32) => (s32)

#GetWindowPosition: @extern proc => (Vector2)

#GetWindowScaleDPI: @extern proc => (Vector2)

#GetMonitorName: @extern proc(monitor: s32) => (^u8)

#SetClipboardText: @extern proc(text: ^u8)

#GetClipboardText: @extern proc => (^u8)

#EnableEventWaiting: @extern proc

#DisableEventWaiting: @extern proc

#SwapScreenBuffer: @extern proc

#PollInputEvents: @extern proc

#WaitTime: @extern proc(seconds: f64)

#ShowCursor: @extern proc

#HideCursor: @extern proc

#IsCursorHidden: @extern proc => (bool)

#EnableCursor: @extern proc

#DisableCursor: @extern proc

#IsCursorOnScreen: @extern proc => (bool)

#ClearBackground: @extern proc(color: Color)

#BeginDrawing: @extern proc

#EndDrawing: @extern proc

#BeginMode2D: @extern proc(camera: Camera2D)

#EndMode2D: @extern proc

#BeginMode3D: @extern proc(camera: Camera3D)

#EndMode3D: @extern proc

#BeginTextureMode: @extern proc(target: RenderTexture2D)

#EndTextureMode: @extern proc

#BeginShaderMode: @extern proc(shader: Shader)

#EndShaderMode: @extern proc

#BeginBlendMode: @extern proc(mode: s32)

#EndBlendMode: @extern proc

#BeginScissorMode: @extern proc(x: s32, y: s32, width: s32, height: s32)

#EndScissorMode: @extern proc

#BeginVrStereoMode: @extern proc(config: VrStereoConfig)

#EndVrStereoMode: @extern proc

#LoadVrStereoConfig: @extern proc(device: VrDeviceInfo) => (VrStereoConfig)

#UnloadVrStereoConfig: @extern proc(config: VrStereoConfig)

#LoadShader: @extern proc(vsFileName: ^u8, fsFileName: ^u8) => (Shader)

#LoadShaderFromMemory: @extern proc(vsCode: ^u8, fsCode: ^u8) => (Shader)

#GetShaderLocation: @extern proc(shader: Shader, uniformName: ^u8) => (s32)

#GetShaderLocationAttrib: @extern proc(shader: Shader, attribName: ^u8) => (s32)

#SetShaderValue: @extern proc(shader: Shader, locIndex: s32, value: ^u8, uniformType: s32)

#SetShaderValueV: @extern proc(shader: Shader, locIndex: s32, value: ^u8, uniformType: s32, count: s32)

#SetShaderValueMatrix: @extern proc(shader: Shader, locIndex: s32, mat: Matrix)

#SetShaderValueTexture: @extern proc(shader: Shader, locIndex: s32, texture: Texture2D)

#UnloadShader: @extern proc(shader: Shader)

#GetMouseRay: @extern proc(mousePosition: Vector2, camera: Camera) => (Ray)

#GetCameraMatrix: @extern proc(camera: Camera) => (Matrix)

#GetCameraMatrix2D: @extern proc(camera: Camera2D) => (Matrix)

#GetWorldToScreen: @extern proc(position: Vector3, camera: Camera) => (Vector2)

#GetScreenToWorld2D: @extern proc(position: Vector2, camera: Camera2D) => (Vector2)

#GetWorldToScreenEx: @extern proc(position: Vector3, camera: Camera, width: s32, height: s32) => (Vector2)

#GetWorldToScreen2D: @extern proc(position: Vector2, camera: Camera2D) => (Vector2)

#SetTargetFPS: @extern proc(fps: s32)

#GetFPS: @extern proc => (s32)

#GetFrameTime: @extern proc => (f32)

#GetTime: @extern proc => (f64)

#GetRandomValue: @extern proc(min: s32, max: s32) => (s32)

#SetRandomSeed: @extern proc(seed: u32)

#TakeScreenshot: @extern proc(fileName: ^u8)

#SetConfigFlags: @extern proc(flags: u32)

#TraceLog: @extern proc(logLevel: s32, text: ^u8)

#SetTraceLogLevel: @extern proc(logLevel: s32)

#MemAlloc: @extern proc(size: u32) => (^u8)

#MemRealloc: @extern proc(ptr: ^u8, size: u32) => (^u8)

#MemFree: @extern proc(ptr: ^u8)

#OpenURL: @extern proc(url: ^u8)

#SetTraceLogCallback: @extern proc(callback: TraceLogCallback)

#SetLoadFileDataCallback: @extern proc(callback: LoadFileDataCallback)

#SetSaveFileDataCallback: @extern proc(callback: SaveFileDataCallback)

#SetLoadFileTextCallback: @extern proc(callback: LoadFileTextCallback)

#SetSaveFileTextCallback: @extern proc(callback: SaveFileTextCallback)

#LoadFileData: @extern proc(fileName: ^u8, bytesRead: ^u32) => (^u8)

#UnloadFileData: @extern proc(data: ^u8)

#SaveFileData: @extern proc(fileName: ^u8, data: ^u8, bytesToWrite: u32) => (bool)

#ExportDataAsCode: @extern proc(data: ^u8, size: u32, fileName: ^u8) => (bool)

#LoadFileText: @extern proc(fileName: ^u8) => (^u8)

#UnloadFileText: @extern proc(text: ^u8)

#SaveFileText: @extern proc(fileName: ^u8, text: ^u8) => (bool)

#FileExists: @extern proc(fileName: ^u8) => (bool)

#DirectoryExists: @extern proc(dirPath: ^u8) => (bool)

#IsFileExtension: @extern proc(fileName: ^u8, ext: ^u8) => (bool)

#GetFileLength: @extern proc(fileName: ^u8) => (s32)

#GetFileExtension: @extern proc(fileName: ^u8) => (^u8)

#GetFileName: @extern proc(filePath: ^u8) => (^u8)

#GetFileNameWithoutExt: @extern proc(filePath: ^u8) => (^u8)

#GetDirectoryPath: @extern proc(filePath: ^u8) => (^u8)

#GetPrevDirectoryPath: @extern proc(dirPath: ^u8) => (^u8)

#GetWorkingDirectory: @extern proc => (^u8)

#GetApplicationDirectory: @extern proc => (^u8)

#ChangeDirectory: @extern proc(dir: ^u8) => (bool)

#IsPathFile: @extern proc(path: ^u8) => (bool)

#LoadDirectoryFiles: @extern proc(dirPath: ^u8) => (FilePathList)

#LoadDirectoryFilesEx: @extern proc(basePath: ^u8, filter: ^u8, scanSubdirs: bool) => (FilePathList)

#UnloadDirectoryFiles: @extern proc(files: FilePathList)

#IsFileDropped: @extern proc => (bool)

#LoadDroppedFiles: @extern proc => (FilePathList)

#UnloadDroppedFiles: @extern proc(files: FilePathList)

#GetFileModTime: @extern proc(fileName: ^u8) => (s32)

#CompressData: @extern proc(data: ^u8, dataSize: s32, compDataSize: ^s32) => (^u8)

#DecompressData: @extern proc(compData: ^u8, compDataSize: s32, dataSize: ^s32) => (^u8)

#EncodeDataBase64: @extern proc(data: ^u8, dataSize: s32, outputSize: ^s32) => (^u8)

#DecodeDataBase64: @extern proc(data: ^u8, outputSize: ^s32) => (^u8)

#IsKeyPressed: @extern proc(key: KeyboardKey) => (bool)

#IsKeyDown: @extern proc(key: KeyboardKey) => (bool)

#IsKeyReleased: @extern proc(key: KeyboardKey) => (bool)

#IsKeyUp: @extern proc(key: KeyboardKey) => (bool)

#SetExitKey: @extern proc(key: KeyboardKey)

#GetKeyPressed: @extern proc => (s32)

#GetCharPressed: @extern proc => (s32)

#IsGamepadAvailable: @extern proc(gamepad: s32) => (bool)

#GetGamepadName: @extern proc(gamepad: s32) => (^u8)

#IsGamepadButtonPressed: @extern proc(gamepad: s32, button: GamepadButton) => (bool)

#IsGamepadButtonDown: @extern proc(gamepad: s32, button: GamepadButton) => (bool)

#IsGamepadButtonReleased: @extern proc(gamepad: s32, button: GamepadButton) => (bool)

#IsGamepadButtonUp: @extern proc(gamepad: s32, button: GamepadButton) => (bool)

#GetGamepadButtonPressed: @extern proc => (s32)

#GetGamepadAxisCount: @extern proc(gamepad: s32) => (s32)

#GetGamepadAxisMovement: @extern proc(gamepad: s32, axis: GamepadAxis) => (f32)

#SetGamepadMappings: @extern proc(mappings: ^u8) => (s32)

#IsMouseButtonPressed: @extern proc(button: MouseButton) => (bool)

#IsMouseButtonDown: @extern proc(button: MouseButton) => (bool)

#IsMouseButtonReleased: @extern proc(button: MouseButton) => (bool)

#IsMouseButtonUp: @extern proc(button: MouseButton) => (bool)

#GetMouseX: @extern proc => (s32)

#GetMouseY: @extern proc => (s32)

#GetMousePosition: @extern proc => (Vector2)

#GetMouseDelta: @extern proc => (Vector2)

#SetMousePosition: @extern proc(x: s32, y: s32)

#SetMouseOffset: @extern proc(offsetX: s32, offsetY: s32)

#SetMouseScale: @extern proc(scaleX: f32, scaleY: f32)

#GetMouseWheelMove: @extern proc => (f32)

#GetMouseWheelMoveV: @extern proc => (Vector2)

#SetMouseCursor: @extern proc(cursor: MouseCursor)

#GetTouchX: @extern proc => (s32)

#GetTouchY: @extern proc => (s32)

#GetTouchPosition: @extern proc(index: s32) => (Vector2)

#GetTouchPointId: @extern proc(index: s32) => (s32)

#GetTouchPointCount: @extern proc => (s32)

#SetGesturesEnabled: @extern proc(flags: u32)

#IsGestureDetected: @extern proc(gesture: s32) => (bool)

#GetGestureDetected: @extern proc => (s32)

#GetGestureHoldDuration: @extern proc => (f32)

#GetGestureDragVector: @extern proc => (Vector2)

#GetGestureDragAngle: @extern proc => (f32)

#GetGesturePinchVector: @extern proc => (Vector2)

#GetGesturePinchAngle: @extern proc => (f32)

#SetCameraMode: @extern proc(camera: Camera, mode: s32)

#UpdateCamera: @extern proc(camera: ^Camera)

#SetCameraPanControl: @extern proc(keyPan: s32)

#SetCameraAltControl: @extern proc(keyAlt: s32)

#SetCameraSmoothZoomControl: @extern proc(keySmoothZoom: s32)

#SetCameraMoveControls: @extern proc(keyFront: s32, keyBack: s32, keyRight: s32, keyLeft: s32, keyUp: s32, keyDown: s32)

#SetShapesTexture: @extern proc(texture: Texture2D, source: Rectangle)

#DrawPixel: @extern proc(posX: s32, posY: s32, color: Color)

#DrawPixelV: @extern proc(position: Vector2, color: Color)

#DrawLine: @extern proc(startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color)

#DrawLineV: @extern proc(startPos: Vector2, endPos: Vector2, color: Color)

#DrawLineEx: @extern proc(startPos: Vector2, endPos: Vector2, thick: f32, color: Color)

#DrawLineBezier: @extern proc(startPos: Vector2, endPos: Vector2, thick: f32, color: Color)

#DrawLineBezierQuad: @extern proc(startPos: Vector2, endPos: Vector2, controlPos: Vector2, thick: f32, color: Color)

#DrawLineBezierCubic: @extern proc(startPos: Vector2, endPos: Vector2, startControlPos: Vector2, endControlPos: Vector2, thick: f32, color: Color)

#DrawLineStrip: @extern proc(points: ^Vector2, pointCount: s32, color: Color)

#DrawCircle: @extern proc(centerX: s32, centerY: s32, radius: f32, color: Color)

#DrawCircleSector: @extern proc(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color)

#DrawCircleSectorLines: @extern proc(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color)

#DrawCircleGradient: @extern proc(centerX: s32, centerY: s32, radius: f32, color1: Color, color2: Color)

#DrawCircleV: @extern proc(center: Vector2, radius: f32, color: Color)

#DrawCircleLines: @extern proc(centerX: s32, centerY: s32, radius: f32, color: Color)

#DrawEllipse: @extern proc(centerX: s32, centerY: s32, radiusH: f32, radiusV: f32, color: Color)

#DrawEllipseLines: @extern proc(centerX: s32, centerY: s32, radiusH: f32, radiusV: f32, color: Color)

#DrawRing: @extern proc(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color)

#DrawRingLines: @extern proc(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color)

#DrawRectangle: @extern proc(posX: s32, posY: s32, width: s32, height: s32, color: Color)

#DrawRectangleV: @extern proc(position: Vector2, size: Vector2, color: Color)

#DrawRectangleRec: @extern proc(rec: Rectangle, color: Color)

#DrawRectanglePro: @extern proc(rec: Rectangle, origin: Vector2, rotation: f32, color: Color)

#DrawRectangleGradientV: @extern proc(posX: s32, posY: s32, width: s32, height: s32, color1: Color, color2: Color)

#DrawRectangleGradientH: @extern proc(posX: s32, posY: s32, width: s32, height: s32, color1: Color, color2: Color)

#DrawRectangleGradientEx: @extern proc(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color)

#DrawRectangleLines: @extern proc(posX: s32, posY: s32, width: s32, height: s32, color: Color)

#DrawRectangleLinesEx: @extern proc(rec: Rectangle, lineThick: f32, color: Color)

#DrawRectangleRounded: @extern proc(rec: Rectangle, roundness: f32, segments: s32, color: Color)

#DrawRectangleRoundedLines: @extern proc(rec: Rectangle, roundness: f32, segments: s32, lineThick: f32, color: Color)

#DrawTriangle: @extern proc(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)

#DrawTriangleLines: @extern proc(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)

#DrawTriangleFan: @extern proc(points: ^Vector2, pointCount: s32, color: Color)

#DrawTriangleStrip: @extern proc(points: ^Vector2, pointCount: s32, color: Color)

#DrawPoly: @extern proc(center: Vector2, sides: s32, radius: f32, rotation: f32, color: Color)

#DrawPolyLines: @extern proc(center: Vector2, sides: s32, radius: f32, rotation: f32, color: Color)

#DrawPolyLinesEx: @extern proc(center: Vector2, sides: s32, radius: f32, rotation: f32, lineThick: f32, color: Color)

#CheckCollisionRecs: @extern proc(rec1: Rectangle, rec2: Rectangle) => (bool)

#CheckCollisionCircles: @extern proc(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32) => (bool)

#CheckCollisionCircleRec: @extern proc(center: Vector2, radius: f32, rec: Rectangle) => (bool)

#CheckCollisionPointRec: @extern proc(point: Vector2, rec: Rectangle) => (bool)

#CheckCollisionPointCircle: @extern proc(point: Vector2, center: Vector2, radius: f32) => (bool)

#CheckCollisionPointTriangle: @extern proc(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) => (bool)

#CheckCollisionPointPoly: @extern proc(point: Vector2, points: ^Vector2, pointCount: s32) => (bool)

#CheckCollisionLines: @extern proc(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: ^Vector2) => (bool)

#CheckCollisionPointLine: @extern proc(point: Vector2, p1: Vector2, p2: Vector2, threshold: s32) => (bool)

#GetCollisionRec: @extern proc(rec1: Rectangle, rec2: Rectangle) => (Rectangle)

#LoadImage: @extern proc(fileName: ^u8) => (Image)

#LoadImageRaw: @extern proc(fileName: ^u8, width: s32, height: s32, format: s32, headerSize: s32) => (Image)

#LoadImageAnim: @extern proc(fileName: ^u8, frames: ^s32) => (Image)

#LoadImageFromMemory: @extern proc(fileType: ^u8, fileData: ^u8, dataSize: s32) => (Image)

#LoadImageFromTexture: @extern proc(texture: Texture2D) => (Image)

#LoadImageFromScreen: @extern proc => (Image)

#UnloadImage: @extern proc(image: Image)

#ExportImage: @extern proc(image: Image, fileName: ^u8) => (bool)

#ExportImageAsCode: @extern proc(image: Image, fileName: ^u8) => (bool)

#GenImageColor: @extern proc(width: s32, height: s32, color: Color) => (Image)

#GenImageGradientV: @extern proc(width: s32, height: s32, top: Color, bottom: Color) => (Image)

#GenImageGradientH: @extern proc(width: s32, height: s32, left: Color, right: Color) => (Image)

#GenImageGradientRadial: @extern proc(width: s32, height: s32, density: f32, inner: Color, outer: Color) => (Image)

#GenImageChecked: @extern proc(width: s32, height: s32, checksX: s32, checksY: s32, col1: Color, col2: Color) => (Image)

#GenImageWhiteNoise: @extern proc(width: s32, height: s32, factor: f32) => (Image)

#GenImagePerlinNoise: @extern proc(width: s32, height: s32, offsetX: s32, offsetY: s32, scale: f32) => (Image)

#GenImageCellular: @extern proc(width: s32, height: s32, tileSize: s32) => (Image)

#GenImageText: @extern proc(width: s32, height: s32, text: ^u8) => (Image)

#ImageCopy: @extern proc(image: Image) => (Image)

#ImageFromImage: @extern proc(image: Image, rec: Rectangle) => (Image)

#ImageText: @extern proc(text: ^u8, fontSize: s32, color: Color) => (Image)

#ImageTextEx: @extern proc(font: Font, text: ^u8, fontSize: f32, spacing: f32, tint: Color) => (Image)

#ImageFormat: @extern proc(image: ^Image, newFormat: s32)

#ImageToPOT: @extern proc(image: ^Image, fill: Color)

#ImageCrop: @extern proc(image: ^Image, crop: Rectangle)

#ImageAlphaCrop: @extern proc(image: ^Image, threshold: f32)

#ImageAlphaClear: @extern proc(image: ^Image, color: Color, threshold: f32)

#ImageAlphaMask: @extern proc(image: ^Image, alphaMask: Image)

#ImageAlphaPremultiply: @extern proc(image: ^Image)

#ImageBlurGaussian: @extern proc(image: ^Image, blurSize: s32)

#ImageResize: @extern proc(image: ^Image, newWidth: s32, newHeight: s32)

#ImageResizeNN: @extern proc(image: ^Image, newWidth: s32, newHeight: s32)

#ImageResizeCanvas: @extern proc(image: ^Image, newWidth: s32, newHeight: s32, offsetX: s32, offsetY: s32, fill: Color)

#ImageMipmaps: @extern proc(image: ^Image)

#ImageDither: @extern proc(image: ^Image, rBpp: s32, gBpp: s32, bBpp: s32, aBpp: s32)

#ImageFlipVertical: @extern proc(image: ^Image)

#ImageFlipHorizontal: @extern proc(image: ^Image)

#ImageRotateCW: @extern proc(image: ^Image)

#ImageRotateCCW: @extern proc(image: ^Image)

#ImageColorTint: @extern proc(image: ^Image, color: Color)

#ImageColorInvert: @extern proc(image: ^Image)

#ImageColorGrayscale: @extern proc(image: ^Image)

#ImageColorContrast: @extern proc(image: ^Image, contrast: f32)

#ImageColorBrightness: @extern proc(image: ^Image, brightness: s32)

#ImageColorReplace: @extern proc(image: ^Image, color: Color, replace: Color)

#LoadImageColors: @extern proc(image: Image) => (^Color)

#LoadImagePalette: @extern proc(image: Image, maxPaletteSize: s32, colorCount: ^s32) => (^Color)

#UnloadImageColors: @extern proc(colors: ^Color)

#UnloadImagePalette: @extern proc(colors: ^Color)

#GetImageAlphaBorder: @extern proc(image: Image, threshold: f32) => (Rectangle)

#GetImageColor: @extern proc(image: Image, x: s32, y: s32) => (Color)

#ImageClearBackground: @extern proc(dst: ^Image, color: Color)

#ImageDrawPixel: @extern proc(dst: ^Image, posX: s32, posY: s32, color: Color)

#ImageDrawPixelV: @extern proc(dst: ^Image, position: Vector2, color: Color)

#ImageDrawLine: @extern proc(dst: ^Image, startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color)

#ImageDrawLineV: @extern proc(dst: ^Image, start: Vector2, end: Vector2, color: Color)

#ImageDrawCircle: @extern proc(dst: ^Image, centerX: s32, centerY: s32, radius: s32, color: Color)

#ImageDrawCircleV: @extern proc(dst: ^Image, center: Vector2, radius: s32, color: Color)

#ImageDrawCircleLines: @extern proc(dst: ^Image, centerX: s32, centerY: s32, radius: s32, color: Color)

#ImageDrawCircleLinesV: @extern proc(dst: ^Image, center: Vector2, radius: s32, color: Color)

#ImageDrawRectangle: @extern proc(dst: ^Image, posX: s32, posY: s32, width: s32, height: s32, color: Color)

#ImageDrawRectangleV: @extern proc(dst: ^Image, position: Vector2, size: Vector2, color: Color)

#ImageDrawRectangleRec: @extern proc(dst: ^Image, rec: Rectangle, color: Color)

#ImageDrawRectangleLines: @extern proc(dst: ^Image, rec: Rectangle, thick: s32, color: Color)

#ImageDraw: @extern proc(dst: ^Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)

#ImageDrawText: @extern proc(dst: ^Image, text: ^u8, posX: s32, posY: s32, fontSize: s32, color: Color)

#ImageDrawTextEx: @extern proc(dst: ^Image, font: Font, text: ^u8, position: Vector2, fontSize: f32, spacing: f32, tint: Color)

#LoadTexture: @extern proc(fileName: ^u8) => (Texture2D)

#LoadTextureFromImage: @extern proc(image: Image) => (Texture2D)

#LoadTextureCubemap: @extern proc(image: Image, layout: s32) => (TextureCubemap)

#LoadRenderTexture: @extern proc(width: s32, height: s32) => (RenderTexture2D)

#UnloadTexture: @extern proc(texture: Texture2D)

#UnloadRenderTexture: @extern proc(target: RenderTexture2D)

#UpdateTexture: @extern proc(texture: Texture2D, pixels: ^u8)

#UpdateTextureRec: @extern proc(texture: Texture2D, rec: Rectangle, pixels: ^u8)

#GenTextureMipmaps: @extern proc(texture: ^Texture2D)

#SetTextureFilter: @extern proc(texture: Texture2D, filter: s32)

#SetTextureWrap: @extern proc(texture: Texture2D, wrap: s32)

#DrawTexture: @extern proc(texture: Texture2D, posX: s32, posY: s32, tint: Color)

#DrawTextureV: @extern proc(texture: Texture2D, position: Vector2, tint: Color)

#DrawTextureEx: @extern proc(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: Color)

#DrawTextureRec: @extern proc(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color)

#DrawTexturePro: @extern proc(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color)

#DrawTextureNPatch: @extern proc(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color)

#Fade: @extern proc(color: Color, alpha: f32) => (Color)

#ColorToInt: @extern proc(color: Color) => (s32)

#ColorNormalize: @extern proc(color: Color) => (Vector4)

#ColorFromNormalized: @extern proc(normalized: Vector4) => (Color)

#ColorToHSV: @extern proc(color: Color) => (Vector3)

#ColorFromHSV: @extern proc(hue: f32, saturation: f32, value: f32) => (Color)

#ColorTint: @extern proc(color: Color, tint: Color) => (Color)

#ColorBrightness: @extern proc(color: Color, factor: f32) => (Color)

#ColorContrast: @extern proc(color: Color, contrast: f32) => (Color)

#ColorAlpha: @extern proc(color: Color, alpha: f32) => (Color)

#ColorAlphaBlend: @extern proc(dst: Color, src: Color, tint: Color) => (Color)

#GetColor: @extern proc(hexValue: u32) => (Color)

#GetPixelColor: @extern proc(srcPtr: ^u8, format: s32) => (Color)

#SetPixelColor: @extern proc(dstPtr: ^u8, color: Color, format: s32)

#GetPixelDataSize: @extern proc(width: s32, height: s32, format: s32) => (s32)

#GetFontDefault: @extern proc => (Font)

#LoadFont: @extern proc(fileName: ^u8) => (Font)

#LoadFontEx: @extern proc(fileName: ^u8, fontSize: s32, fontChars: ^s32, glyphCount: s32) => (Font)

#LoadFontFromImage: @extern proc(image: Image, key: Color, firstChar: s32) => (Font)

#LoadFontFromMemory: @extern proc(fileType: ^u8, fileData: ^u8, dataSize: s32, fontSize: s32, fontChars: ^s32, glyphCount: s32) => (Font)

#LoadFontData: @extern proc(fileData: ^u8, dataSize: s32, fontSize: s32, fontChars: ^s32, glyphCount: s32, type: s32) => (^GlyphInfo)

#GenImageFontAtlas: @extern proc(chars: ^GlyphInfo, recs: ^^Rectangle, glyphCount: s32, fontSize: s32, padding: s32, packMethod: s32) => (Image)

#UnloadFontData: @extern proc(chars: ^GlyphInfo, glyphCount: s32)

#UnloadFont: @extern proc(font: Font)

#ExportFontAsCode: @extern proc(font: Font, fileName: ^u8) => (bool)

#DrawFPS: @extern proc(posX: s32, posY: s32)

#DrawText: @extern proc(text: ^u8, posX: s32, posY: s32, fontSize: s32, color: Color)

#DrawTextEx: @extern proc(font: Font, text: ^u8, position: Vector2, fontSize: f32, spacing: f32, tint: Color)

#DrawTextPro: @extern proc(font: Font, text: ^u8, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: Color)

#DrawTextCodepoint: @extern proc(font: Font, codepoint: s32, position: Vector2, fontSize: f32, tint: Color)

#DrawTextCodepoints: @extern proc(font: Font, codepoints: ^s32, count: s32, position: Vector2, fontSize: f32, spacing: f32, tint: Color)

#MeasureText: @extern proc(text: ^u8, fontSize: s32) => (s32)

#MeasureTextEx: @extern proc(font: Font, text: ^u8, fontSize: f32, spacing: f32) => (Vector2)

#GetGlyphIndex: @extern proc(font: Font, codepoint: s32) => (s32)

#GetGlyphInfo: @extern proc(font: Font, codepoint: s32) => (GlyphInfo)

#GetGlyphAtlasRec: @extern proc(font: Font, codepoint: s32) => (Rectangle)

#LoadUTF8: @extern proc(codepoints: ^s32, length: s32) => (^u8)

#UnloadUTF8: @extern proc(text: ^u8)

#LoadCodepoints: @extern proc(text: ^u8, count: ^s32) => (^s32)

#UnloadCodepoints: @extern proc(codepoints: ^s32)

#GetCodepointCount: @extern proc(text: ^u8) => (s32)

#GetCodepoint: @extern proc(text: ^u8, codepointSize: ^s32) => (s32)

#GetCodepointNext: @extern proc(text: ^u8, codepointSize: ^s32) => (s32)

#GetCodepointPrevious: @extern proc(text: ^u8, codepointSize: ^s32) => (s32)

#CodepointToUTF8: @extern proc(codepoint: s32, utf8Size: ^s32) => (^u8)

#TextCopy: @extern proc(dst: ^u8, src: ^u8) => (s32)

#TextIsEqual: @extern proc(text1: ^u8, text2: ^u8) => (bool)

#TextLength: @extern proc(text: ^u8) => (u32)

#TextFormat: @extern proc(text: ^u8) => (^u8)

#TextSubtext: @extern proc(text: ^u8, position: s32, length: s32) => (^u8)

#TextReplace: @extern proc(text: ^u8, replace: ^u8, by: ^u8) => (^u8)

#TextInsert: @extern proc(text: ^u8, insert: ^u8, position: s32) => (^u8)

#TextJoin: @extern proc(textList: ^^u8, count: s32, delimiter: ^u8) => (^u8)

#TextSplit: @extern proc(text: ^u8, delimiter: u8, count: ^s32) => (^^u8)

#TextAppend: @extern proc(text: ^u8, append: ^u8, position: ^s32)

#TextFindIndex: @extern proc(text: ^u8, find: ^u8) => (s32)

#TextToUpper: @extern proc(text: ^u8) => (^u8)

#TextToLower: @extern proc(text: ^u8) => (^u8)

#TextToPascal: @extern proc(text: ^u8) => (^u8)

#TextToInteger: @extern proc(text: ^u8) => (s32)

#DrawLine3D: @extern proc(startPos: Vector3, endPos: Vector3, color: Color)

#DrawPoint3D: @extern proc(position: Vector3, color: Color)

#DrawCircle3D: @extern proc(center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color)

#DrawTriangle3D: @extern proc(v1: Vector3, v2: Vector3, v3: Vector3, color: Color)

#DrawTriangleStrip3D: @extern proc(points: ^Vector3, pointCount: s32, color: Color)

#DrawCube: @extern proc(position: Vector3, width: f32, height: f32, length: f32, color: Color)

#DrawCubeV: @extern proc(position: Vector3, size: Vector3, color: Color)

#DrawCubeWires: @extern proc(position: Vector3, width: f32, height: f32, length: f32, color: Color)

#DrawCubeWiresV: @extern proc(position: Vector3, size: Vector3, color: Color)

#DrawSphere: @extern proc(centerPos: Vector3, radius: f32, color: Color)

#DrawSphereEx: @extern proc(centerPos: Vector3, radius: f32, rings: s32, slices: s32, color: Color)

#DrawSphereWires: @extern proc(centerPos: Vector3, radius: f32, rings: s32, slices: s32, color: Color)

#DrawCylinder: @extern proc(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: s32, color: Color)

#DrawCylinderEx: @extern proc(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: s32, color: Color)

#DrawCylinderWires: @extern proc(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: s32, color: Color)

#DrawCylinderWiresEx: @extern proc(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: s32, color: Color)

#DrawCapsule: @extern proc(startPos: Vector3, endPos: Vector3, radius: f32, slices: s32, rings: s32, color: Color)

#DrawCapsuleWires: @extern proc(startPos: Vector3, endPos: Vector3, radius: f32, slices: s32, rings: s32, color: Color)

#DrawPlane: @extern proc(centerPos: Vector3, size: Vector2, color: Color)

#DrawRay: @extern proc(ray: Ray, color: Color)

#DrawGrid: @extern proc(slices: s32, spacing: f32)

#LoadModel: @extern proc(fileName: ^u8) => (Model)

#LoadModelFromMesh: @extern proc(mesh: Mesh) => (Model)

#UnloadModel: @extern proc(model: Model)

#UnloadModelKeepMeshes: @extern proc(model: Model)

#GetModelBoundingBox: @extern proc(model: Model) => (BoundingBox)

#DrawModel: @extern proc(model: Model, position: Vector3, scale: f32, tint: Color)

#DrawModelEx: @extern proc(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)

#DrawModelWires: @extern proc(model: Model, position: Vector3, scale: f32, tint: Color)

#DrawModelWiresEx: @extern proc(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)

#DrawBoundingBox: @extern proc(box: BoundingBox, color: Color)

#DrawBillboard: @extern proc(camera: Camera, texture: Texture2D, position: Vector3, size: f32, tint: Color)

#DrawBillboardRec: @extern proc(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color)

#DrawBillboardPro: @extern proc(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color)

#UploadMesh: @extern proc(mesh: ^Mesh, dynamic: bool)

#UpdateMeshBuffer: @extern proc(mesh: Mesh, index: s32, data: ^u8, dataSize: s32, offset: s32)

#UnloadMesh: @extern proc(mesh: Mesh)

#DrawMesh: @extern proc(mesh: Mesh, material: Material, transform: Matrix)

#DrawMeshInstanced: @extern proc(mesh: Mesh, material: Material, transforms: ^Matrix, instances: s32)

#ExportMesh: @extern proc(mesh: Mesh, fileName: ^u8) => (bool)

#GetMeshBoundingBox: @extern proc(mesh: Mesh) => (BoundingBox)

#GenMeshTangents: @extern proc(mesh: ^Mesh)

#GenMeshPoly: @extern proc(sides: s32, radius: f32) => (Mesh)

#GenMeshPlane: @extern proc(width: f32, length: f32, resX: s32, resZ: s32) => (Mesh)

#GenMeshCube: @extern proc(width: f32, height: f32, length: f32) => (Mesh)

#GenMeshSphere: @extern proc(radius: f32, rings: s32, slices: s32) => (Mesh)

#GenMeshHemiSphere: @extern proc(radius: f32, rings: s32, slices: s32) => (Mesh)

#GenMeshCylinder: @extern proc(radius: f32, height: f32, slices: s32) => (Mesh)

#GenMeshCone: @extern proc(radius: f32, height: f32, slices: s32) => (Mesh)

#GenMeshTorus: @extern proc(radius: f32, size: f32, radSeg: s32, sides: s32) => (Mesh)

#GenMeshKnot: @extern proc(radius: f32, size: f32, radSeg: s32, sides: s32) => (Mesh)

#GenMeshHeightmap: @extern proc(heightmap: Image, size: Vector3) => (Mesh)

#GenMeshCubicmap: @extern proc(cubicmap: Image, cubeSize: Vector3) => (Mesh)

#LoadMaterials: @extern proc(fileName: ^u8, materialCount: ^s32) => (^Material)

#LoadMaterialDefault: @extern proc => (Material)

#UnloadMaterial: @extern proc(material: Material)

#SetMaterialTexture: @extern proc(material: ^Material, mapType: s32, texture: Texture2D)

#SetModelMeshMaterial: @extern proc(model: ^Model, meshId: s32, materialId: s32)

#LoadModelAnimations: @extern proc(fileName: ^u8, animCount: ^u32) => (^ModelAnimation)

#UpdateModelAnimation: @extern proc(model: Model, anim: ModelAnimation, frame: s32)

#UnloadModelAnimation: @extern proc(anim: ModelAnimation)

#UnloadModelAnimations: @extern proc(animations: ^ModelAnimation, count: u32)

#IsModelAnimationValid: @extern proc(model: Model, anim: ModelAnimation) => (bool)

#CheckCollisionSpheres: @extern proc(center1: Vector3, radius1: f32, center2: Vector3, radius2: f32) => (bool)

#CheckCollisionBoxes: @extern proc(box1: BoundingBox, box2: BoundingBox) => (bool)

#CheckCollisionBoxSphere: @extern proc(box: BoundingBox, center: Vector3, radius: f32) => (bool)

#GetRayCollisionSphere: @extern proc(ray: Ray, center: Vector3, radius: f32) => (RayCollision)

#GetRayCollisionBox: @extern proc(ray: Ray, box: BoundingBox) => (RayCollision)

#GetRayCollisionMesh: @extern proc(ray: Ray, mesh: Mesh, transform: Matrix) => (RayCollision)

#GetRayCollisionTriangle: @extern proc(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) => (RayCollision)

#GetRayCollisionQuad: @extern proc(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) => (RayCollision)

#InitAudioDevice: @extern proc

#CloseAudioDevice: @extern proc

#IsAudioDeviceReady: @extern proc => (bool)

#SetMasterVolume: @extern proc(volume: f32)

#LoadWave: @extern proc(fileName: ^u8) => (Wave)

#LoadWaveFromMemory: @extern proc(fileType: ^u8, fileData: ^u8, dataSize: s32) => (Wave)

#LoadSound: @extern proc(fileName: ^u8) => (Sound)

#LoadSoundFromWave: @extern proc(wave: Wave) => (Sound)

#UpdateSound: @extern proc(sound: Sound, data: ^u8, sampleCount: s32)

#UnloadWave: @extern proc(wave: Wave)

#UnloadSound: @extern proc(sound: Sound)

#ExportWave: @extern proc(wave: Wave, fileName: ^u8) => (bool)

#ExportWaveAsCode: @extern proc(wave: Wave, fileName: ^u8) => (bool)

#PlaySound: @extern proc(sound: Sound)

#StopSound: @extern proc(sound: Sound)

#PauseSound: @extern proc(sound: Sound)

#ResumeSound: @extern proc(sound: Sound)

#PlaySoundMulti: @extern proc(sound: Sound)

#StopSoundMulti: @extern proc

#GetSoundsPlaying: @extern proc => (s32)

#IsSoundPlaying: @extern proc(sound: Sound) => (bool)

#SetSoundVolume: @extern proc(sound: Sound, volume: f32)

#SetSoundPitch: @extern proc(sound: Sound, pitch: f32)

#SetSoundPan: @extern proc(sound: Sound, pan: f32)

#WaveCopy: @extern proc(wave: Wave) => (Wave)

#WaveCrop: @extern proc(wave: ^Wave, initSample: s32, finalSample: s32)

#WaveFormat: @extern proc(wave: ^Wave, sampleRate: s32, sampleSize: s32, channels: s32)

#LoadWaveSamples: @extern proc(wave: Wave) => (^f32)

#UnloadWaveSamples: @extern proc(samples: ^f32)

#LoadMusicStream: @extern proc(fileName: ^u8) => (Music)

#LoadMusicStreamFromMemory: @extern proc(fileType: ^u8, data: ^u8, dataSize: s32) => (Music)

#UnloadMusicStream: @extern proc(music: Music)

#PlayMusicStream: @extern proc(music: Music)

#IsMusicStreamPlaying: @extern proc(music: Music) => (bool)

#UpdateMusicStream: @extern proc(music: Music)

#StopMusicStream: @extern proc(music: Music)

#PauseMusicStream: @extern proc(music: Music)

#ResumeMusicStream: @extern proc(music: Music)

#SeekMusicStream: @extern proc(music: Music, position: f32)

#SetMusicVolume: @extern proc(music: Music, volume: f32)

#SetMusicPitch: @extern proc(music: Music, pitch: f32)

#SetMusicPan: @extern proc(music: Music, pan: f32)

#GetMusicTimeLength: @extern proc(music: Music) => (f32)

#GetMusicTimePlayed: @extern proc(music: Music) => (f32)

#LoadAudioStream: @extern proc(sampleRate: u32, sampleSize: u32, channels: u32) => (AudioStream)

#UnloadAudioStream: @extern proc(stream: AudioStream)

#UpdateAudioStream: @extern proc(stream: AudioStream, data: ^u8, frameCount: s32)

#IsAudioStreamProcessed: @extern proc(stream: AudioStream) => (bool)

#PlayAudioStream: @extern proc(stream: AudioStream)

#PauseAudioStream: @extern proc(stream: AudioStream)

#ResumeAudioStream: @extern proc(stream: AudioStream)

#IsAudioStreamPlaying: @extern proc(stream: AudioStream) => (bool)

#StopAudioStream: @extern proc(stream: AudioStream)

#SetAudioStreamVolume: @extern proc(stream: AudioStream, volume: f32)

#SetAudioStreamPitch: @extern proc(stream: AudioStream, pitch: f32)

#SetAudioStreamPan: @extern proc(stream: AudioStream, pan: f32)

#SetAudioStreamBufferSizeDefault: @extern proc(size: s32)

#SetAudioStreamCallback: @extern proc(stream: AudioStream, callback: AudioCallback)

#AttachAudioStreamProcessor: @extern proc(stream: AudioStream, processor: AudioCallback)

#DetachAudioStreamProcessor: @extern proc(stream: AudioStream, processor: AudioCallback)

