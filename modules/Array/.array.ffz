// hmm. I'm not sure if this should go inside the Basic module, as Basic/Array.
// I guess that depends on whether anything inside Basic requires an array implementation.

#B: import("../Basic")

// TODO: @alias_module_name


#Array: struct[T] {
	@using{} slice: []T
	capacity: uint
	allocator: ^B.Allocator
}

#make: proc[T](allocator: ^B.Allocator) => Array[T] {
	a: Array[T]
	a.allocator= allocator
	
	ret a
}

#free: proc[T](a: ^Array[T]) {
	foo: []raw
	a.allocator._proc(a.allocator, a.ptr, a.capacity*size_of(T), 0, 0)
}

#push: proc[T](a: ^Array[T], elem: T) => uint {
	ret push_raw(^Array[raw](a), &elem, size_of(T), align_of(T))
}

// --
// Raw array utilities - these are useful if you don't know the element type statically.
// --

#push_raw: proc(a: ^Array[raw], elem: ^raw, elem_size: uint, elem_align: uint) => uint {
	if (a.len >= a.capacity) { // Do we need to grow the array?
		new_capacity: B.max[uint](8, a.capacity*2)
		
		a.ptr= a.allocator._proc(a.allocator, a.ptr, a.capacity*elem_size, new_capacity*elem_size, elem_align)
		a.capacity= new_capacity
	}
	
	B.memmove(^raw(uint(a.ptr) + elem_size * a.len), elem, elem_size)
	
	out: a.len
	a.len= .+1
	ret out
}
