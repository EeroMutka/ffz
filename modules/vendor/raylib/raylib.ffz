// This file was generated by library_translator.

/// -------------------

@extern{":winmm.lib"}
@extern{":kernel32.lib"}
@extern{":gdi32.lib"}
@extern{":user32.lib"}
@extern{":shell32.lib"}
#raylib: extern{"raylib.lib"}

#f32: u32
#f64: u64

/// -------------------


#Vector2: struct {
	x: f32
	y: f32
}

#Vector3: struct {
	x: f32
	y: f32
	z: f32
}

#Vector4: struct {
	x: f32
	y: f32
	z: f32
	w: f32
}

#Quaternion: struct {
	x: f32
	y: f32
	z: f32
	w: f32
}

#Matrix: struct {
	m0: f32
	m4: f32
	m8: f32
	m12: f32
	m1: f32
	m5: f32
	m9: f32
	m13: f32
	m2: f32
	m6: f32
	m10: f32
	m14: f32
	m3: f32
	m7: f32
	m11: f32
	m15: f32
}

#Color: struct {
	r: u8
	g: u8
	b: u8
	a: u8
}

#Rectangle: struct {
	x: f32
	y: f32
	width: f32
	height: f32
}

#Image: struct {
	data: ^u8
	width: s32
	height: s32
	mipmaps: s32
	format: s32
}

#Texture: struct {
	id: u32
	width: s32
	height: s32
	mipmaps: s32
	format: s32
}

#Texture2D: struct {
	id: u32
	width: s32
	height: s32
	mipmaps: s32
	format: s32
}

#TextureCubemap: struct {
	id: u32
	width: s32
	height: s32
	mipmaps: s32
	format: s32
}

#RenderTexture: struct {
	id: u32
	texture: Texture
	depth: Texture
}

#RenderTexture2D: struct {
	id: u32
	texture: Texture
	depth: Texture
}

#NPatchInfo: struct {
	source: Rectangle
	left: s32
	top: s32
	right: s32
	bottom: s32
	layout: s32
}

#GlyphInfo: struct {
	value: s32
	offsetX: s32
	offsetY: s32
	advanceX: s32
	image: Image
}

#Font: struct {
	baseSize: s32
	glyphCount: s32
	glyphPadding: s32
	texture: Texture2D
	recs: ^Rectangle
	glyphs: ^GlyphInfo
}

#Camera3D: struct {
	position: Vector3
	target: Vector3
	up: Vector3
	fovy: f32
	projection: s32
}

#Camera: struct {
	position: Vector3
	target: Vector3
	up: Vector3
	fovy: f32
	projection: s32
}

#Camera2D: struct {
	offset: Vector2
	target: Vector2
	rotation: f32
	zoom: f32
}

#Mesh: struct {
	vertexCount: s32
	triangleCount: s32
	vertices: ^f32
	texcoords: ^f32
	texcoords2: ^f32
	normals: ^f32
	tangents: ^f32
	colors: ^u8
	indices: ^u16
	animVertices: ^f32
	animNormals: ^f32
	boneIds: ^u8
	boneWeights: ^f32
	vaoId: u32
	vboId: ^u32
}

#Shader: struct {
	id: u32
	locs: ^s32
}

#MaterialMap: struct {
	texture: Texture2D
	color: Color
	value: f32
}

#Material: struct {
	shader: Shader
	maps: ^MaterialMap
	params: [4]f32
}

#Transform: struct {
	translation: Vector3
	rotation: Quaternion
	scale: Vector3
}

#BoneInfo: struct {
	name: [32]u8
	parent: s32
}

#Model: struct {
	transform: Matrix
	meshCount: s32
	materialCount: s32
	meshes: ^Mesh
	materials: ^Material
	meshMaterial: ^s32
	boneCount: s32
	bones: ^BoneInfo
	bindPose: ^Transform
}

#ModelAnimation: struct {
	boneCount: s32
	frameCount: s32
	bones: ^BoneInfo
	framePoses: ^^Transform
}

#Ray: struct {
	position: Vector3
	direction: Vector3
}

#RayCollision: struct {
	hit: bool
	distance: f32
	point: Vector3
	normal: Vector3
}

#BoundingBox: struct {
	min: Vector3
	max: Vector3
}

#Wave: struct {
	frameCount: u32
	sampleRate: u32
	sampleSize: u32
	channels: u32
	data: ^u8
}

#rAudioBuffer: struct {
}

#rAudioProcessor: struct {
}

#AudioStream: struct {
	buffer: ^rAudioBuffer
	processor: ^rAudioProcessor
	sampleRate: u32
	sampleSize: u32
	channels: u32
}

#Sound: struct {
	stream: AudioStream
	frameCount: u32
}

#Music: struct {
	stream: AudioStream
	frameCount: u32
	looping: bool
	ctxType: s32
	ctxData: ^u8
}

#VrDeviceInfo: struct {
	hResolution: s32
	vResolution: s32
	hScreenSize: f32
	vScreenSize: f32
	vScreenCenter: f32
	eyeToScreenDistance: f32
	lensSeparationDistance: f32
	interpupillaryDistance: f32
	lensDistortionValues: [4]f32
	chromaAbCorrection: [4]f32
}

#VrStereoConfig: struct {
	projection: [2]Matrix
	viewOffset: [2]Matrix
	leftLensCenter: [2]f32
	rightLensCenter: [2]f32
	leftScreenCenter: [2]f32
	rightScreenCenter: [2]f32
	scale: [2]f32
	scaleIn: [2]f32
}

#FilePathList: struct {
	capacity: u32
	count: u32
	paths: ^^u8
}

#ConfigFlags: enum, u32 {
	VSYNC_HINT: 64
	FULLSCREEN_MODE: 2
	WINDOW_RESIZABLE: 4
	WINDOW_UNDECORATED: 8
	WINDOW_HIDDEN: 128
	WINDOW_MINIMIZED: 512
	WINDOW_MAXIMIZED: 1024
	WINDOW_UNFOCUSED: 2048
	WINDOW_TOPMOST: 4096
	WINDOW_ALWAYS_RUN: 256
	WINDOW_TRANSPARENT: 16
	WINDOW_HIGHDPI: 8192
	WINDOW_MOUSE_PASSTHROUGH: 16384
	MSAA_4X_HINT: 32
	INTERLACED_HINT: 65536
}

#TraceLogLevel: enum, u32 {
	ALL: 0
	TRACE: 1
	DEBUG: 2
	INFO: 3
	WARNING: 4
	ERROR: 5
	FATAL: 6
	NONE: 7
}

#KeyboardKey: enum, u32 {
	NULL: 0
	APOSTROPHE: 39
	COMMA: 44
	MINUS: 45
	PERIOD: 46
	SLASH: 47
	ZERO: 48
	ONE: 49
	TWO: 50
	THREE: 51
	FOUR: 52
	FIVE: 53
	SIX: 54
	SEVEN: 55
	EIGHT: 56
	NINE: 57
	SEMICOLON: 59
	EQUAL: 61
	A: 65
	B: 66
	C: 67
	D: 68
	E: 69
	F: 70
	G: 71
	H: 72
	I: 73
	J: 74
	K: 75
	L: 76
	M: 77
	N: 78
	O: 79
	P: 80
	Q: 81
	R: 82
	S: 83
	T: 84
	U: 85
	V: 86
	W: 87
	X: 88
	Y: 89
	Z: 90
	LEFT_BRACKET: 91
	BACKSLASH: 92
	RIGHT_BRACKET: 93
	GRAVE: 96
	SPACE: 32
	ESCAPE: 256
	ENTER: 257
	TAB: 258
	BACKSPACE: 259
	INSERT: 260
	DELETE: 261
	RIGHT: 262
	LEFT: 263
	DOWN: 264
	UP: 265
	PAGE_UP: 266
	PAGE_DOWN: 267
	HOME: 268
	END: 269
	CAPS_LOCK: 280
	SCROLL_LOCK: 281
	NUM_LOCK: 282
	PRINT_SCREEN: 283
	PAUSE: 284
	F1: 290
	F2: 291
	F3: 292
	F4: 293
	F5: 294
	F6: 295
	F7: 296
	F8: 297
	F9: 298
	F10: 299
	F11: 300
	F12: 301
	LEFT_SHIFT: 340
	LEFT_CONTROL: 341
	LEFT_ALT: 342
	LEFT_SUPER: 343
	RIGHT_SHIFT: 344
	RIGHT_CONTROL: 345
	RIGHT_ALT: 346
	RIGHT_SUPER: 347
	KB_MENU: 348
	KP_0: 320
	KP_1: 321
	KP_2: 322
	KP_3: 323
	KP_4: 324
	KP_5: 325
	KP_6: 326
	KP_7: 327
	KP_8: 328
	KP_9: 329
	KP_DECIMAL: 330
	KP_DIVIDE: 331
	KP_MULTIPLY: 332
	KP_SUBTRACT: 333
	KP_ADD: 334
	KP_ENTER: 335
	KP_EQUAL: 336
/* hmm... ffz currently doesn't allow for shared enum values.
	BACK: 4
	MENU: 82
	VOLUME_UP: 24
	VOLUME_DOWN: 25
 */
}

#MouseButton: enum, u32 {
	LEFT: 0
	RIGHT: 1
	MIDDLE: 2
	SIDE: 3
	EXTRA: 4
	FORWARD: 5
	BACK: 6
}

#MouseCursor: enum, u32 {
	DEFAULT: 0
	ARROW: 1
	IBEAM: 2
	CROSSHAIR: 3
	POINTING_HAND: 4
	RESIZE_EW: 5
	RESIZE_NS: 6
	RESIZE_NWSE: 7
	RESIZE_NESW: 8
	RESIZE_ALL: 9
	NOT_ALLOWED: 10
}

#GamepadButton: enum, u32 {
	UNKNOWN: 0
	LEFT_FACE_UP: 1
	LEFT_FACE_RIGHT: 2
	LEFT_FACE_DOWN: 3
	LEFT_FACE_LEFT: 4
	RIGHT_FACE_UP: 5
	RIGHT_FACE_RIGHT: 6
	RIGHT_FACE_DOWN: 7
	RIGHT_FACE_LEFT: 8
	LEFT_TRIGGER_1: 9
	LEFT_TRIGGER_2: 10
	RIGHT_TRIGGER_1: 11
	RIGHT_TRIGGER_2: 12
	MIDDLE_LEFT: 13
	MIDDLE: 14
	MIDDLE_RIGHT: 15
	LEFT_THUMB: 16
	RIGHT_THUMB: 17
}

#GamepadAxis: enum, u32 {
	LEFT_X: 0
	LEFT_Y: 1
	RIGHT_X: 2
	RIGHT_Y: 3
	LEFT_TRIGGER: 4
	RIGHT_TRIGGER: 5
}

#MaterialMapIndex: enum, u32 {
	ALBEDO: 0
	METALNESS: 1
	NORMAL: 2
	ROUGHNESS: 3
	OCCLUSION: 4
	EMISSION: 5
	HEIGHT: 6
	CUBEMAP: 7
	IRRADIANCE: 8
	PREFILTER: 9
	BRDF: 10
}

#ShaderLocationIndex: enum, u32 {
	VERTEX_POSITION: 0
	VERTEX_TEXCOORD01: 1
	VERTEX_TEXCOORD02: 2
	VERTEX_NORMAL: 3
	VERTEX_TANGENT: 4
	VERTEX_COLOR: 5
	MATRIX_MVP: 6
	MATRIX_VIEW: 7
	MATRIX_PROJECTION: 8
	MATRIX_MODEL: 9
	MATRIX_NORMAL: 10
	VECTOR_VIEW: 11
	COLOR_DIFFUSE: 12
	COLOR_SPECULAR: 13
	COLOR_AMBIENT: 14
	MAP_ALBEDO: 15
	MAP_METALNESS: 16
	MAP_NORMAL: 17
	MAP_ROUGHNESS: 18
	MAP_OCCLUSION: 19
	MAP_EMISSION: 20
	MAP_HEIGHT: 21
	MAP_CUBEMAP: 22
	MAP_IRRADIANCE: 23
	MAP_PREFILTER: 24
	MAP_BRDF: 25
}

#ShaderUniformDataType: enum, u32 {
	FLOAT: 0
	VEC2: 1
	VEC3: 2
	VEC4: 3
	INT: 4
	IVEC2: 5
	IVEC3: 6
	IVEC4: 7
	SAMPLER2D: 8
}

#ShaderAttributeDataType: enum, u32 {
	FLOAT: 0
	VEC2: 1
	VEC3: 2
	VEC4: 3
}

#PixelFormat: enum, u32 {
	UNCOMPRESSED_GRAYSCALE: 1
	UNCOMPRESSED_GRAY_ALPHA: 2
	UNCOMPRESSED_R5G6B5: 3
	UNCOMPRESSED_R8G8B8: 4
	UNCOMPRESSED_R5G5B5A1: 5
	UNCOMPRESSED_R4G4B4A4: 6
	UNCOMPRESSED_R8G8B8A8: 7
	UNCOMPRESSED_R32: 8
	UNCOMPRESSED_R32G32B32: 9
	UNCOMPRESSED_R32G32B32A32: 10
	COMPRESSED_DXT1_RGB: 11
	COMPRESSED_DXT1_RGBA: 12
	COMPRESSED_DXT3_RGBA: 13
	COMPRESSED_DXT5_RGBA: 14
	COMPRESSED_ETC1_RGB: 15
	COMPRESSED_ETC2_RGB: 16
	COMPRESSED_ETC2_EAC_RGBA: 17
	COMPRESSED_PVRT_RGB: 18
	COMPRESSED_PVRT_RGBA: 19
	COMPRESSED_ASTC_4x4_RGBA: 20
	COMPRESSED_ASTC_8x8_RGBA: 21
}

#TextureFilter: enum, u32 {
	POINT: 0
	BILINEAR: 1
	TRILINEAR: 2
	ANISOTROPIC_4X: 3
	ANISOTROPIC_8X: 4
	ANISOTROPIC_16X: 5
}

#TextureWrap: enum, u32 {
	REPEAT: 0
	CLAMP: 1
	MIRROR_REPEAT: 2
	MIRROR_CLAMP: 3
}

#CubemapLayout: enum, u32 {
	AUTO_DETECT: 0
	LINE_VERTICAL: 1
	LINE_HORIZONTAL: 2
	CROSS_THREE_BY_FOUR: 3
	CROSS_FOUR_BY_THREE: 4
	PANORAMA: 5
}

#FontType: enum, u32 {
	DEFAULT: 0
	BITMAP: 1
	SDF: 2
}

#BlendMode: enum, u32 {
	ALPHA: 0
	ADDITIVE: 1
	MULTIPLIED: 2
	ADD_COLORS: 3
	SUBTRACT_COLORS: 4
	ALPHA_PREMULTIPLY: 5
	CUSTOM: 6
	CUSTOM_SEPARATE: 7
}

#Gesture: enum, u32 {
	NONE: 0
	TAP: 1
	DOUBLETAP: 2
	HOLD: 4
	DRAG: 8
	SWIPE_RIGHT: 16
	SWIPE_LEFT: 32
	SWIPE_UP: 64
	SWIPE_DOWN: 128
	PINCH_IN: 256
	PINCH_OUT: 512
}

#CameraMode: enum, u32 {
	CUSTOM: 0
	FREE: 1
	ORBITAL: 2
	FIRST_PERSON: 3
	THIRD_PERSON: 4
}

#CameraProjection: enum, u32 {
	PERSPECTIVE: 0
	ORTHOGRAPHIC: 1
}

#NPatchLayout: enum, u32 {
	NINE_PATCH: 0
	THREE_PATCH_VERTICAL: 1
	THREE_PATCH_HORIZONTAL: 2
}

#TraceLogCallback: proc(logLevel: s32, text: ^u8 /*, args: va_list*/)

#LoadFileDataCallback: proc(fileName: ^u8, bytesRead: ^u32) => (^u8)

#SaveFileDataCallback: proc(fileName: ^u8, data: ^u8, bytesToWrite: u32) => (bool)

#LoadFileTextCallback: proc(fileName: ^u8) => (^u8)

#SaveFileTextCallback: proc(fileName: ^u8, text: ^u8) => (bool)

#AudioCallback: proc(bufferData: ^u8, frames: u32)

@raylib #InitWindow: proc(width: s32, height: s32, title: ^u8)

@raylib #WindowShouldClose: proc => (bool)

@raylib #CloseWindow: proc

@raylib #IsWindowReady: proc => (bool)

@raylib #IsWindowFullscreen: proc => (bool)

@raylib #IsWindowHidden: proc => (bool)

@raylib #IsWindowMinimized: proc => (bool)

@raylib #IsWindowMaximized: proc => (bool)

@raylib #IsWindowFocused: proc => (bool)

@raylib #IsWindowResized: proc => (bool)

@raylib #IsWindowState: proc(flag: u32) => (bool)

@raylib #SetWindowState: proc(flags: u32)

@raylib #ClearWindowState: proc(flags: u32)

@raylib #ToggleFullscreen: proc

@raylib #MaximizeWindow: proc

@raylib #MinimizeWindow: proc

@raylib #RestoreWindow: proc

@raylib #SetWindowIcon: proc(image: Image)

@raylib #SetWindowTitle: proc(title: ^u8)

@raylib #SetWindowPosition: proc(x: s32, y: s32)

@raylib #SetWindowMonitor: proc(monitor: s32)

@raylib #SetWindowMinSize: proc(width: s32, height: s32)

@raylib #SetWindowSize: proc(width: s32, height: s32)

@raylib #SetWindowOpacity: proc(opacity: f32)

@raylib #GetWindowHandle: proc => (^u8)

@raylib #GetScreenWidth: proc => (s32)

@raylib #GetScreenHeight: proc => (s32)

@raylib #GetRenderWidth: proc => (s32)

@raylib #GetRenderHeight: proc => (s32)

@raylib #GetMonitorCount: proc => (s32)

@raylib #GetCurrentMonitor: proc => (s32)

@raylib #GetMonitorPosition: proc(monitor: s32) => (Vector2)

@raylib #GetMonitorWidth: proc(monitor: s32) => (s32)

@raylib #GetMonitorHeight: proc(monitor: s32) => (s32)

@raylib #GetMonitorPhysicalWidth: proc(monitor: s32) => (s32)

@raylib #GetMonitorPhysicalHeight: proc(monitor: s32) => (s32)

@raylib #GetMonitorRefreshRate: proc(monitor: s32) => (s32)

@raylib #GetWindowPosition: proc => (Vector2)

@raylib #GetWindowScaleDPI: proc => (Vector2)

@raylib #GetMonitorName: proc(monitor: s32) => (^u8)

@raylib #SetClipboardText: proc(text: ^u8)

@raylib #GetClipboardText: proc => (^u8)

@raylib #EnableEventWaiting: proc

@raylib #DisableEventWaiting: proc

@raylib #SwapScreenBuffer: proc

@raylib #PollInputEvents: proc

@raylib #WaitTime: proc(seconds: f64)

@raylib #ShowCursor: proc

@raylib #HideCursor: proc

@raylib #IsCursorHidden: proc => (bool)

@raylib #EnableCursor: proc

@raylib #DisableCursor: proc

@raylib #IsCursorOnScreen: proc => (bool)

@raylib #ClearBackground: proc(color: Color)

@raylib #BeginDrawing: proc

@raylib #EndDrawing: proc

@raylib #BeginMode2D: proc(camera: Camera2D)

@raylib #EndMode2D: proc

@raylib #BeginMode3D: proc(camera: Camera3D)

@raylib #EndMode3D: proc

@raylib #BeginTextureMode: proc(target: RenderTexture2D)

@raylib #EndTextureMode: proc

@raylib #BeginShaderMode: proc(shader: Shader)

@raylib #EndShaderMode: proc

@raylib #BeginBlendMode: proc(mode: s32)

@raylib #EndBlendMode: proc

@raylib #BeginScissorMode: proc(x: s32, y: s32, width: s32, height: s32)

@raylib #EndScissorMode: proc

@raylib #BeginVrStereoMode: proc(config: VrStereoConfig)

@raylib #EndVrStereoMode: proc

@raylib #LoadVrStereoConfig: proc(device: VrDeviceInfo) => (VrStereoConfig)

@raylib #UnloadVrStereoConfig: proc(config: VrStereoConfig)

@raylib #LoadShader: proc(vsFileName: ^u8, fsFileName: ^u8) => (Shader)

@raylib #LoadShaderFromMemory: proc(vsCode: ^u8, fsCode: ^u8) => (Shader)

@raylib #GetShaderLocation: proc(shader: Shader, uniformName: ^u8) => (s32)

@raylib #GetShaderLocationAttrib: proc(shader: Shader, attribName: ^u8) => (s32)

@raylib #SetShaderValue: proc(shader: Shader, locIndex: s32, value: ^u8, uniformType: s32)

@raylib #SetShaderValueV: proc(shader: Shader, locIndex: s32, value: ^u8, uniformType: s32, count: s32)

@raylib #SetShaderValueMatrix: proc(shader: Shader, locIndex: s32, mat: Matrix)

@raylib #SetShaderValueTexture: proc(shader: Shader, locIndex: s32, texture: Texture2D)

@raylib #UnloadShader: proc(shader: Shader)

@raylib #GetMouseRay: proc(mousePosition: Vector2, camera: Camera) => (Ray)

@raylib #GetCameraMatrix: proc(camera: Camera) => (Matrix)

@raylib #GetCameraMatrix2D: proc(camera: Camera2D) => (Matrix)

@raylib #GetWorldToScreen: proc(position: Vector3, camera: Camera) => (Vector2)

@raylib #GetScreenToWorld2D: proc(position: Vector2, camera: Camera2D) => (Vector2)

@raylib #GetWorldToScreenEx: proc(position: Vector3, camera: Camera, width: s32, height: s32) => (Vector2)

@raylib #GetWorldToScreen2D: proc(position: Vector2, camera: Camera2D) => (Vector2)

@raylib #SetTargetFPS: proc(fps: s32)

@raylib #GetFPS: proc => (s32)

@raylib #GetFrameTime: proc => (f32)

@raylib #GetTime: proc => (f64)

@raylib #GetRandomValue: proc(min: s32, max: s32) => (s32)

@raylib #SetRandomSeed: proc(seed: u32)

@raylib #TakeScreenshot: proc(fileName: ^u8)

@raylib #SetConfigFlags: proc(flags: u32)

@raylib #TraceLog: proc(logLevel: s32, text: ^u8)

@raylib #SetTraceLogLevel: proc(logLevel: s32)

@raylib #MemAlloc: proc(size: u32) => (^u8)

@raylib #MemRealloc: proc(ptr: ^u8, size: u32) => (^u8)

@raylib #MemFree: proc(ptr: ^u8)

@raylib #OpenURL: proc(url: ^u8)

@raylib #SetTraceLogCallback: proc(callback: TraceLogCallback)

@raylib #SetLoadFileDataCallback: proc(callback: LoadFileDataCallback)

@raylib #SetSaveFileDataCallback: proc(callback: SaveFileDataCallback)

@raylib #SetLoadFileTextCallback: proc(callback: LoadFileTextCallback)

@raylib #SetSaveFileTextCallback: proc(callback: SaveFileTextCallback)

@raylib #LoadFileData: proc(fileName: ^u8, bytesRead: ^u32) => (^u8)

@raylib #UnloadFileData: proc(data: ^u8)

@raylib #SaveFileData: proc(fileName: ^u8, data: ^u8, bytesToWrite: u32) => (bool)

@raylib #ExportDataAsCode: proc(data: ^u8, size: u32, fileName: ^u8) => (bool)

@raylib #LoadFileText: proc(fileName: ^u8) => (^u8)

@raylib #UnloadFileText: proc(text: ^u8)

@raylib #SaveFileText: proc(fileName: ^u8, text: ^u8) => (bool)

@raylib #FileExists: proc(fileName: ^u8) => (bool)

@raylib #DirectoryExists: proc(dirPath: ^u8) => (bool)

@raylib #IsFileExtension: proc(fileName: ^u8, ext: ^u8) => (bool)

@raylib #GetFileLength: proc(fileName: ^u8) => (s32)

@raylib #GetFileExtension: proc(fileName: ^u8) => (^u8)

@raylib #GetFileName: proc(filePath: ^u8) => (^u8)

@raylib #GetFileNameWithoutExt: proc(filePath: ^u8) => (^u8)

@raylib #GetDirectoryPath: proc(filePath: ^u8) => (^u8)

@raylib #GetPrevDirectoryPath: proc(dirPath: ^u8) => (^u8)

@raylib #GetWorkingDirectory: proc => (^u8)

@raylib #GetApplicationDirectory: proc => (^u8)

@raylib #ChangeDirectory: proc(dir: ^u8) => (bool)

@raylib #IsPathFile: proc(path: ^u8) => (bool)

@raylib #LoadDirectoryFiles: proc(dirPath: ^u8) => (FilePathList)

@raylib #LoadDirectoryFilesEx: proc(basePath: ^u8, filter: ^u8, scanSubdirs: bool) => (FilePathList)

@raylib #UnloadDirectoryFiles: proc(files: FilePathList)

@raylib #IsFileDropped: proc => (bool)

@raylib #LoadDroppedFiles: proc => (FilePathList)

@raylib #UnloadDroppedFiles: proc(files: FilePathList)

@raylib #GetFileModTime: proc(fileName: ^u8) => (s32)

@raylib #CompressData: proc(data: ^u8, dataSize: s32, compDataSize: ^s32) => (^u8)

@raylib #DecompressData: proc(compData: ^u8, compDataSize: s32, dataSize: ^s32) => (^u8)

@raylib #EncodeDataBase64: proc(data: ^u8, dataSize: s32, outputSize: ^s32) => (^u8)

@raylib #DecodeDataBase64: proc(data: ^u8, outputSize: ^s32) => (^u8)

@raylib #IsKeyPressed: proc(key: KeyboardKey) => (bool)

@raylib #IsKeyDown: proc(key: KeyboardKey) => (bool)

@raylib #IsKeyReleased: proc(key: KeyboardKey) => (bool)

@raylib #IsKeyUp: proc(key: KeyboardKey) => (bool)

@raylib #SetExitKey: proc(key: KeyboardKey)

@raylib #GetKeyPressed: proc => (s32)

@raylib #GetCharPressed: proc => (s32)

@raylib #IsGamepadAvailable: proc(gamepad: s32) => (bool)

@raylib #GetGamepadName: proc(gamepad: s32) => (^u8)

@raylib #IsGamepadButtonPressed: proc(gamepad: s32, button: GamepadButton) => (bool)

@raylib #IsGamepadButtonDown: proc(gamepad: s32, button: GamepadButton) => (bool)

@raylib #IsGamepadButtonReleased: proc(gamepad: s32, button: GamepadButton) => (bool)

@raylib #IsGamepadButtonUp: proc(gamepad: s32, button: GamepadButton) => (bool)

@raylib #GetGamepadButtonPressed: proc => (s32)

@raylib #GetGamepadAxisCount: proc(gamepad: s32) => (s32)

@raylib #GetGamepadAxisMovement: proc(gamepad: s32, axis: GamepadAxis) => (f32)

@raylib #SetGamepadMappings: proc(mappings: ^u8) => (s32)

@raylib #IsMouseButtonPressed: proc(button: MouseButton) => (bool)

@raylib #IsMouseButtonDown: proc(button: MouseButton) => (bool)

@raylib #IsMouseButtonReleased: proc(button: MouseButton) => (bool)

@raylib #IsMouseButtonUp: proc(button: MouseButton) => (bool)

@raylib #GetMouseX: proc => (s32)

@raylib #GetMouseY: proc => (s32)

@raylib #GetMousePosition: proc => (Vector2)

@raylib #GetMouseDelta: proc => (Vector2)

@raylib #SetMousePosition: proc(x: s32, y: s32)

@raylib #SetMouseOffset: proc(offsetX: s32, offsetY: s32)

@raylib #SetMouseScale: proc(scaleX: f32, scaleY: f32)

@raylib #GetMouseWheelMove: proc => (f32)

@raylib #GetMouseWheelMoveV: proc => (Vector2)

@raylib #SetMouseCursor: proc(cursor: MouseCursor)

@raylib #GetTouchX: proc => (s32)

@raylib #GetTouchY: proc => (s32)

@raylib #GetTouchPosition: proc(index: s32) => (Vector2)

@raylib #GetTouchPointId: proc(index: s32) => (s32)

@raylib #GetTouchPointCount: proc => (s32)

@raylib #SetGesturesEnabled: proc(flags: u32)

@raylib #IsGestureDetected: proc(gesture: s32) => (bool)

@raylib #GetGestureDetected: proc => (s32)

@raylib #GetGestureHoldDuration: proc => (f32)

@raylib #GetGestureDragVector: proc => (Vector2)

@raylib #GetGestureDragAngle: proc => (f32)

@raylib #GetGesturePinchVector: proc => (Vector2)

@raylib #GetGesturePinchAngle: proc => (f32)

@raylib #SetCameraMode: proc(camera: Camera, mode: s32)

@raylib #UpdateCamera: proc(camera: ^Camera)

@raylib #SetCameraPanControl: proc(keyPan: s32)

@raylib #SetCameraAltControl: proc(keyAlt: s32)

@raylib #SetCameraSmoothZoomControl: proc(keySmoothZoom: s32)

@raylib #SetCameraMoveControls: proc(keyFront: s32, keyBack: s32, keyRight: s32, keyLeft: s32, keyUp: s32, keyDown: s32)

@raylib #SetShapesTexture: proc(texture: Texture2D, source: Rectangle)

@raylib #DrawPixel: proc(posX: s32, posY: s32, color: Color)

@raylib #DrawPixelV: proc(position: Vector2, color: Color)

@raylib #DrawLine: proc(startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color)

@raylib #DrawLineV: proc(startPos: Vector2, endPos: Vector2, color: Color)

@raylib #DrawLineEx: proc(startPos: Vector2, endPos: Vector2, thick: f32, color: Color)

@raylib #DrawLineBezier: proc(startPos: Vector2, endPos: Vector2, thick: f32, color: Color)

@raylib #DrawLineBezierQuad: proc(startPos: Vector2, endPos: Vector2, controlPos: Vector2, thick: f32, color: Color)

@raylib #DrawLineBezierCubic: proc(startPos: Vector2, endPos: Vector2, startControlPos: Vector2, endControlPos: Vector2, thick: f32, color: Color)

@raylib #DrawLineStrip: proc(points: ^Vector2, pointCount: s32, color: Color)

@raylib #DrawCircle: proc(centerX: s32, centerY: s32, radius: f32, color: Color)

@raylib #DrawCircleSector: proc(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color)

@raylib #DrawCircleSectorLines: proc(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color)

@raylib #DrawCircleGradient: proc(centerX: s32, centerY: s32, radius: f32, color1: Color, color2: Color)

@raylib #DrawCircleV: proc(center: Vector2, radius: f32, color: Color)

@raylib #DrawCircleLines: proc(centerX: s32, centerY: s32, radius: f32, color: Color)

@raylib #DrawEllipse: proc(centerX: s32, centerY: s32, radiusH: f32, radiusV: f32, color: Color)

@raylib #DrawEllipseLines: proc(centerX: s32, centerY: s32, radiusH: f32, radiusV: f32, color: Color)

@raylib #DrawRing: proc(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color)

@raylib #DrawRingLines: proc(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color)

@raylib #DrawRectangle: proc(posX: s32, posY: s32, width: s32, height: s32, color: Color)

@raylib #DrawRectangleV: proc(position: Vector2, size: Vector2, color: Color)

@raylib #DrawRectangleRec: proc(rec: Rectangle, color: Color)

@raylib #DrawRectanglePro: proc(rec: Rectangle, origin: Vector2, rotation: f32, color: Color)

@raylib #DrawRectangleGradientV: proc(posX: s32, posY: s32, width: s32, height: s32, color1: Color, color2: Color)

@raylib #DrawRectangleGradientH: proc(posX: s32, posY: s32, width: s32, height: s32, color1: Color, color2: Color)

@raylib #DrawRectangleGradientEx: proc(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color)

@raylib #DrawRectangleLines: proc(posX: s32, posY: s32, width: s32, height: s32, color: Color)

@raylib #DrawRectangleLinesEx: proc(rec: Rectangle, lineThick: f32, color: Color)

@raylib #DrawRectangleRounded: proc(rec: Rectangle, roundness: f32, segments: s32, color: Color)

@raylib #DrawRectangleRoundedLines: proc(rec: Rectangle, roundness: f32, segments: s32, lineThick: f32, color: Color)

@raylib #DrawTriangle: proc(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)

@raylib #DrawTriangleLines: proc(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)

@raylib #DrawTriangleFan: proc(points: ^Vector2, pointCount: s32, color: Color)

@raylib #DrawTriangleStrip: proc(points: ^Vector2, pointCount: s32, color: Color)

@raylib #DrawPoly: proc(center: Vector2, sides: s32, radius: f32, rotation: f32, color: Color)

@raylib #DrawPolyLines: proc(center: Vector2, sides: s32, radius: f32, rotation: f32, color: Color)

@raylib #DrawPolyLinesEx: proc(center: Vector2, sides: s32, radius: f32, rotation: f32, lineThick: f32, color: Color)

@raylib #CheckCollisionRecs: proc(rec1: Rectangle, rec2: Rectangle) => (bool)

@raylib #CheckCollisionCircles: proc(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32) => (bool)

@raylib #CheckCollisionCircleRec: proc(center: Vector2, radius: f32, rec: Rectangle) => (bool)

@raylib #CheckCollisionPointRec: proc(point: Vector2, rec: Rectangle) => (bool)

@raylib #CheckCollisionPointCircle: proc(point: Vector2, center: Vector2, radius: f32) => (bool)

@raylib #CheckCollisionPointTriangle: proc(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) => (bool)

@raylib #CheckCollisionPointPoly: proc(point: Vector2, points: ^Vector2, pointCount: s32) => (bool)

@raylib #CheckCollisionLines: proc(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: ^Vector2) => (bool)

@raylib #CheckCollisionPointLine: proc(point: Vector2, p1: Vector2, p2: Vector2, threshold: s32) => (bool)

@raylib #GetCollisionRec: proc(rec1: Rectangle, rec2: Rectangle) => (Rectangle)

@raylib #LoadImage: proc(fileName: ^u8) => (Image)

@raylib #LoadImageRaw: proc(fileName: ^u8, width: s32, height: s32, format: s32, headerSize: s32) => (Image)

@raylib #LoadImageAnim: proc(fileName: ^u8, frames: ^s32) => (Image)

@raylib #LoadImageFromMemory: proc(fileType: ^u8, fileData: ^u8, dataSize: s32) => (Image)

@raylib #LoadImageFromTexture: proc(texture: Texture2D) => (Image)

@raylib #LoadImageFromScreen: proc => (Image)

@raylib #UnloadImage: proc(image: Image)

@raylib #ExportImage: proc(image: Image, fileName: ^u8) => (bool)

@raylib #ExportImageAsCode: proc(image: Image, fileName: ^u8) => (bool)

@raylib #GenImageColor: proc(width: s32, height: s32, color: Color) => (Image)

@raylib #GenImageGradientV: proc(width: s32, height: s32, top: Color, bottom: Color) => (Image)

@raylib #GenImageGradientH: proc(width: s32, height: s32, left: Color, right: Color) => (Image)

@raylib #GenImageGradientRadial: proc(width: s32, height: s32, density: f32, inner: Color, outer: Color) => (Image)

@raylib #GenImageChecked: proc(width: s32, height: s32, checksX: s32, checksY: s32, col1: Color, col2: Color) => (Image)

@raylib #GenImageWhiteNoise: proc(width: s32, height: s32, factor: f32) => (Image)

@raylib #GenImagePerlinNoise: proc(width: s32, height: s32, offsetX: s32, offsetY: s32, scale: f32) => (Image)

@raylib #GenImageCellular: proc(width: s32, height: s32, tileSize: s32) => (Image)

@raylib #GenImageText: proc(width: s32, height: s32, text: ^u8) => (Image)

@raylib #ImageCopy: proc(image: Image) => (Image)

@raylib #ImageFromImage: proc(image: Image, rec: Rectangle) => (Image)

@raylib #ImageText: proc(text: ^u8, fontSize: s32, color: Color) => (Image)

@raylib #ImageTextEx: proc(font: Font, text: ^u8, fontSize: f32, spacing: f32, tint: Color) => (Image)

@raylib #ImageFormat: proc(image: ^Image, newFormat: s32)

@raylib #ImageToPOT: proc(image: ^Image, fill: Color)

@raylib #ImageCrop: proc(image: ^Image, crop: Rectangle)

@raylib #ImageAlphaCrop: proc(image: ^Image, threshold: f32)

@raylib #ImageAlphaClear: proc(image: ^Image, color: Color, threshold: f32)

@raylib #ImageAlphaMask: proc(image: ^Image, alphaMask: Image)

@raylib #ImageAlphaPremultiply: proc(image: ^Image)

@raylib #ImageBlurGaussian: proc(image: ^Image, blurSize: s32)

@raylib #ImageResize: proc(image: ^Image, newWidth: s32, newHeight: s32)

@raylib #ImageResizeNN: proc(image: ^Image, newWidth: s32, newHeight: s32)

@raylib #ImageResizeCanvas: proc(image: ^Image, newWidth: s32, newHeight: s32, offsetX: s32, offsetY: s32, fill: Color)

@raylib #ImageMipmaps: proc(image: ^Image)

@raylib #ImageDither: proc(image: ^Image, rBpp: s32, gBpp: s32, bBpp: s32, aBpp: s32)

@raylib #ImageFlipVertical: proc(image: ^Image)

@raylib #ImageFlipHorizontal: proc(image: ^Image)

@raylib #ImageRotateCW: proc(image: ^Image)

@raylib #ImageRotateCCW: proc(image: ^Image)

@raylib #ImageColorTint: proc(image: ^Image, color: Color)

@raylib #ImageColorInvert: proc(image: ^Image)

@raylib #ImageColorGrayscale: proc(image: ^Image)

@raylib #ImageColorContrast: proc(image: ^Image, contrast: f32)

@raylib #ImageColorBrightness: proc(image: ^Image, brightness: s32)

@raylib #ImageColorReplace: proc(image: ^Image, color: Color, replace: Color)

@raylib #LoadImageColors: proc(image: Image) => (^Color)

@raylib #LoadImagePalette: proc(image: Image, maxPaletteSize: s32, colorCount: ^s32) => (^Color)

@raylib #UnloadImageColors: proc(colors: ^Color)

@raylib #UnloadImagePalette: proc(colors: ^Color)

@raylib #GetImageAlphaBorder: proc(image: Image, threshold: f32) => (Rectangle)

@raylib #GetImageColor: proc(image: Image, x: s32, y: s32) => (Color)

@raylib #ImageClearBackground: proc(dst: ^Image, color: Color)

@raylib #ImageDrawPixel: proc(dst: ^Image, posX: s32, posY: s32, color: Color)

@raylib #ImageDrawPixelV: proc(dst: ^Image, position: Vector2, color: Color)

@raylib #ImageDrawLine: proc(dst: ^Image, startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color)

@raylib #ImageDrawLineV: proc(dst: ^Image, start: Vector2, end: Vector2, color: Color)

@raylib #ImageDrawCircle: proc(dst: ^Image, centerX: s32, centerY: s32, radius: s32, color: Color)

@raylib #ImageDrawCircleV: proc(dst: ^Image, center: Vector2, radius: s32, color: Color)

@raylib #ImageDrawCircleLines: proc(dst: ^Image, centerX: s32, centerY: s32, radius: s32, color: Color)

@raylib #ImageDrawCircleLinesV: proc(dst: ^Image, center: Vector2, radius: s32, color: Color)

@raylib #ImageDrawRectangle: proc(dst: ^Image, posX: s32, posY: s32, width: s32, height: s32, color: Color)

@raylib #ImageDrawRectangleV: proc(dst: ^Image, position: Vector2, size: Vector2, color: Color)

@raylib #ImageDrawRectangleRec: proc(dst: ^Image, rec: Rectangle, color: Color)

@raylib #ImageDrawRectangleLines: proc(dst: ^Image, rec: Rectangle, thick: s32, color: Color)

@raylib #ImageDraw: proc(dst: ^Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)

@raylib #ImageDrawText: proc(dst: ^Image, text: ^u8, posX: s32, posY: s32, fontSize: s32, color: Color)

@raylib #ImageDrawTextEx: proc(dst: ^Image, font: Font, text: ^u8, position: Vector2, fontSize: f32, spacing: f32, tint: Color)

@raylib #LoadTexture: proc(fileName: ^u8) => (Texture2D)

@raylib #LoadTextureFromImage: proc(image: Image) => (Texture2D)

@raylib #LoadTextureCubemap: proc(image: Image, layout: s32) => (TextureCubemap)

@raylib #LoadRenderTexture: proc(width: s32, height: s32) => (RenderTexture2D)

@raylib #UnloadTexture: proc(texture: Texture2D)

@raylib #UnloadRenderTexture: proc(target: RenderTexture2D)

@raylib #UpdateTexture: proc(texture: Texture2D, pixels: ^u8)

@raylib #UpdateTextureRec: proc(texture: Texture2D, rec: Rectangle, pixels: ^u8)

@raylib #GenTextureMipmaps: proc(texture: ^Texture2D)

@raylib #SetTextureFilter: proc(texture: Texture2D, filter: s32)

@raylib #SetTextureWrap: proc(texture: Texture2D, wrap: s32)

@raylib #DrawTexture: proc(texture: Texture2D, posX: s32, posY: s32, tint: Color)

@raylib #DrawTextureV: proc(texture: Texture2D, position: Vector2, tint: Color)

@raylib #DrawTextureEx: proc(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: Color)

@raylib #DrawTextureRec: proc(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color)

@raylib #DrawTexturePro: proc(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color)

@raylib #DrawTextureNPatch: proc(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color)

@raylib #Fade: proc(color: Color, alpha: f32) => (Color)

@raylib #ColorToInt: proc(color: Color) => (s32)

@raylib #ColorNormalize: proc(color: Color) => (Vector4)

@raylib #ColorFromNormalized: proc(normalized: Vector4) => (Color)

@raylib #ColorToHSV: proc(color: Color) => (Vector3)

@raylib #ColorFromHSV: proc(hue: f32, saturation: f32, value: f32) => (Color)

@raylib #ColorTint: proc(color: Color, tint: Color) => (Color)

@raylib #ColorBrightness: proc(color: Color, factor: f32) => (Color)

@raylib #ColorContrast: proc(color: Color, contrast: f32) => (Color)

@raylib #ColorAlpha: proc(color: Color, alpha: f32) => (Color)

@raylib #ColorAlphaBlend: proc(dst: Color, src: Color, tint: Color) => (Color)

@raylib #GetColor: proc(hexValue: u32) => (Color)

@raylib #GetPixelColor: proc(srcPtr: ^u8, format: s32) => (Color)

@raylib #SetPixelColor: proc(dstPtr: ^u8, color: Color, format: s32)

@raylib #GetPixelDataSize: proc(width: s32, height: s32, format: s32) => (s32)

@raylib #GetFontDefault: proc => (Font)

@raylib #LoadFont: proc(fileName: ^u8) => (Font)

@raylib #LoadFontEx: proc(fileName: ^u8, fontSize: s32, fontChars: ^s32, glyphCount: s32) => (Font)

@raylib #LoadFontFromImage: proc(image: Image, key: Color, firstChar: s32) => (Font)

@raylib #LoadFontFromMemory: proc(fileType: ^u8, fileData: ^u8, dataSize: s32, fontSize: s32, fontChars: ^s32, glyphCount: s32) => (Font)

@raylib #LoadFontData: proc(fileData: ^u8, dataSize: s32, fontSize: s32, fontChars: ^s32, glyphCount: s32, type: s32) => (^GlyphInfo)

@raylib #GenImageFontAtlas: proc(chars: ^GlyphInfo, recs: ^^Rectangle, glyphCount: s32, fontSize: s32, padding: s32, packMethod: s32) => (Image)

@raylib #UnloadFontData: proc(chars: ^GlyphInfo, glyphCount: s32)

@raylib #UnloadFont: proc(font: Font)

@raylib #ExportFontAsCode: proc(font: Font, fileName: ^u8) => (bool)

@raylib #DrawFPS: proc(posX: s32, posY: s32)

@raylib #DrawText: proc(text: ^u8, posX: s32, posY: s32, fontSize: s32, color: Color)

@raylib #DrawTextEx: proc(font: Font, text: ^u8, position: Vector2, fontSize: f32, spacing: f32, tint: Color)

@raylib #DrawTextPro: proc(font: Font, text: ^u8, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: Color)

@raylib #DrawTextCodepoint: proc(font: Font, codepoint: s32, position: Vector2, fontSize: f32, tint: Color)

@raylib #DrawTextCodepoints: proc(font: Font, codepoints: ^s32, count: s32, position: Vector2, fontSize: f32, spacing: f32, tint: Color)

@raylib #MeasureText: proc(text: ^u8, fontSize: s32) => (s32)

@raylib #MeasureTextEx: proc(font: Font, text: ^u8, fontSize: f32, spacing: f32) => (Vector2)

@raylib #GetGlyphIndex: proc(font: Font, codepoint: s32) => (s32)

@raylib #GetGlyphInfo: proc(font: Font, codepoint: s32) => (GlyphInfo)

@raylib #GetGlyphAtlasRec: proc(font: Font, codepoint: s32) => (Rectangle)

@raylib #LoadUTF8: proc(codepoints: ^s32, length: s32) => (^u8)

@raylib #UnloadUTF8: proc(text: ^u8)

@raylib #LoadCodepoints: proc(text: ^u8, count: ^s32) => (^s32)

@raylib #UnloadCodepoints: proc(codepoints: ^s32)

@raylib #GetCodepointCount: proc(text: ^u8) => (s32)

@raylib #GetCodepoint: proc(text: ^u8, codepointSize: ^s32) => (s32)

@raylib #GetCodepointNext: proc(text: ^u8, codepointSize: ^s32) => (s32)

@raylib #GetCodepointPrevious: proc(text: ^u8, codepointSize: ^s32) => (s32)

@raylib #CodepointToUTF8: proc(codepoint: s32, utf8Size: ^s32) => (^u8)

@raylib #TextCopy: proc(dst: ^u8, src: ^u8) => (s32)

@raylib #TextIsEqual: proc(text1: ^u8, text2: ^u8) => (bool)

@raylib #TextLength: proc(text: ^u8) => (u32)

@raylib #TextFormat: proc(text: ^u8) => (^u8)

@raylib #TextSubtext: proc(text: ^u8, position: s32, length: s32) => (^u8)

@raylib #TextReplace: proc(text: ^u8, replace: ^u8, by: ^u8) => (^u8)

@raylib #TextInsert: proc(text: ^u8, insert: ^u8, position: s32) => (^u8)

@raylib #TextJoin: proc(textList: ^^u8, count: s32, delimiter: ^u8) => (^u8)

@raylib #TextSplit: proc(text: ^u8, delimiter: u8, count: ^s32) => (^^u8)

@raylib #TextAppend: proc(text: ^u8, append: ^u8, position: ^s32)

@raylib #TextFindIndex: proc(text: ^u8, find: ^u8) => (s32)

@raylib #TextToUpper: proc(text: ^u8) => (^u8)

@raylib #TextToLower: proc(text: ^u8) => (^u8)

@raylib #TextToPascal: proc(text: ^u8) => (^u8)

@raylib #TextToInteger: proc(text: ^u8) => (s32)

@raylib #DrawLine3D: proc(startPos: Vector3, endPos: Vector3, color: Color)

@raylib #DrawPoint3D: proc(position: Vector3, color: Color)

@raylib #DrawCircle3D: proc(center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color)

@raylib #DrawTriangle3D: proc(v1: Vector3, v2: Vector3, v3: Vector3, color: Color)

@raylib #DrawTriangleStrip3D: proc(points: ^Vector3, pointCount: s32, color: Color)

@raylib #DrawCube: proc(position: Vector3, width: f32, height: f32, length: f32, color: Color)

@raylib #DrawCubeV: proc(position: Vector3, size: Vector3, color: Color)

@raylib #DrawCubeWires: proc(position: Vector3, width: f32, height: f32, length: f32, color: Color)

@raylib #DrawCubeWiresV: proc(position: Vector3, size: Vector3, color: Color)

@raylib #DrawSphere: proc(centerPos: Vector3, radius: f32, color: Color)

@raylib #DrawSphereEx: proc(centerPos: Vector3, radius: f32, rings: s32, slices: s32, color: Color)

@raylib #DrawSphereWires: proc(centerPos: Vector3, radius: f32, rings: s32, slices: s32, color: Color)

@raylib #DrawCylinder: proc(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: s32, color: Color)

@raylib #DrawCylinderEx: proc(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: s32, color: Color)

@raylib #DrawCylinderWires: proc(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: s32, color: Color)

@raylib #DrawCylinderWiresEx: proc(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: s32, color: Color)

@raylib #DrawCapsule: proc(startPos: Vector3, endPos: Vector3, radius: f32, slices: s32, rings: s32, color: Color)

@raylib #DrawCapsuleWires: proc(startPos: Vector3, endPos: Vector3, radius: f32, slices: s32, rings: s32, color: Color)

@raylib #DrawPlane: proc(centerPos: Vector3, size: Vector2, color: Color)

@raylib #DrawRay: proc(ray: Ray, color: Color)

@raylib #DrawGrid: proc(slices: s32, spacing: f32)

@raylib #LoadModel: proc(fileName: ^u8) => (Model)

@raylib #LoadModelFromMesh: proc(mesh: Mesh) => (Model)

@raylib #UnloadModel: proc(model: Model)

@raylib #UnloadModelKeepMeshes: proc(model: Model)

@raylib #GetModelBoundingBox: proc(model: Model) => (BoundingBox)

@raylib #DrawModel: proc(model: Model, position: Vector3, scale: f32, tint: Color)

@raylib #DrawModelEx: proc(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)

@raylib #DrawModelWires: proc(model: Model, position: Vector3, scale: f32, tint: Color)

@raylib #DrawModelWiresEx: proc(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)

@raylib #DrawBoundingBox: proc(box: BoundingBox, color: Color)

@raylib #DrawBillboard: proc(camera: Camera, texture: Texture2D, position: Vector3, size: f32, tint: Color)

@raylib #DrawBillboardRec: proc(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color)

@raylib #DrawBillboardPro: proc(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color)

@raylib #UploadMesh: proc(mesh: ^Mesh, dynamic: bool)

@raylib #UpdateMeshBuffer: proc(mesh: Mesh, index: s32, data: ^u8, dataSize: s32, offset: s32)

@raylib #UnloadMesh: proc(mesh: Mesh)

@raylib #DrawMesh: proc(mesh: Mesh, material: Material, transform: Matrix)

@raylib #DrawMeshInstanced: proc(mesh: Mesh, material: Material, transforms: ^Matrix, instances: s32)

@raylib #ExportMesh: proc(mesh: Mesh, fileName: ^u8) => (bool)

@raylib #GetMeshBoundingBox: proc(mesh: Mesh) => (BoundingBox)

@raylib #GenMeshTangents: proc(mesh: ^Mesh)

@raylib #GenMeshPoly: proc(sides: s32, radius: f32) => (Mesh)

@raylib #GenMeshPlane: proc(width: f32, length: f32, resX: s32, resZ: s32) => (Mesh)

@raylib #GenMeshCube: proc(width: f32, height: f32, length: f32) => (Mesh)

@raylib #GenMeshSphere: proc(radius: f32, rings: s32, slices: s32) => (Mesh)

@raylib #GenMeshHemiSphere: proc(radius: f32, rings: s32, slices: s32) => (Mesh)

@raylib #GenMeshCylinder: proc(radius: f32, height: f32, slices: s32) => (Mesh)

@raylib #GenMeshCone: proc(radius: f32, height: f32, slices: s32) => (Mesh)

@raylib #GenMeshTorus: proc(radius: f32, size: f32, radSeg: s32, sides: s32) => (Mesh)

@raylib #GenMeshKnot: proc(radius: f32, size: f32, radSeg: s32, sides: s32) => (Mesh)

@raylib #GenMeshHeightmap: proc(heightmap: Image, size: Vector3) => (Mesh)

@raylib #GenMeshCubicmap: proc(cubicmap: Image, cubeSize: Vector3) => (Mesh)

@raylib #LoadMaterials: proc(fileName: ^u8, materialCount: ^s32) => (^Material)

@raylib #LoadMaterialDefault: proc => (Material)

@raylib #UnloadMaterial: proc(material: Material)

@raylib #SetMaterialTexture: proc(material: ^Material, mapType: s32, texture: Texture2D)

@raylib #SetModelMeshMaterial: proc(model: ^Model, meshId: s32, materialId: s32)

@raylib #LoadModelAnimations: proc(fileName: ^u8, animCount: ^u32) => (^ModelAnimation)

@raylib #UpdateModelAnimation: proc(model: Model, anim: ModelAnimation, frame: s32)

@raylib #UnloadModelAnimation: proc(anim: ModelAnimation)

@raylib #UnloadModelAnimations: proc(animations: ^ModelAnimation, count: u32)

@raylib #IsModelAnimationValid: proc(model: Model, anim: ModelAnimation) => (bool)

@raylib #CheckCollisionSpheres: proc(center1: Vector3, radius1: f32, center2: Vector3, radius2: f32) => (bool)

@raylib #CheckCollisionBoxes: proc(box1: BoundingBox, box2: BoundingBox) => (bool)

@raylib #CheckCollisionBoxSphere: proc(box: BoundingBox, center: Vector3, radius: f32) => (bool)

@raylib #GetRayCollisionSphere: proc(ray: Ray, center: Vector3, radius: f32) => (RayCollision)

@raylib #GetRayCollisionBox: proc(ray: Ray, box: BoundingBox) => (RayCollision)

@raylib #GetRayCollisionMesh: proc(ray: Ray, mesh: Mesh, transform: Matrix) => (RayCollision)

@raylib #GetRayCollisionTriangle: proc(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) => (RayCollision)

@raylib #GetRayCollisionQuad: proc(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) => (RayCollision)

@raylib #InitAudioDevice: proc

@raylib #CloseAudioDevice: proc

@raylib #IsAudioDeviceReady: proc => (bool)

@raylib #SetMasterVolume: proc(volume: f32)

@raylib #LoadWave: proc(fileName: ^u8) => (Wave)

@raylib #LoadWaveFromMemory: proc(fileType: ^u8, fileData: ^u8, dataSize: s32) => (Wave)

@raylib #LoadSound: proc(fileName: ^u8) => (Sound)

@raylib #LoadSoundFromWave: proc(wave: Wave) => (Sound)

@raylib #UpdateSound: proc(sound: Sound, data: ^u8, sampleCount: s32)

@raylib #UnloadWave: proc(wave: Wave)

@raylib #UnloadSound: proc(sound: Sound)

@raylib #ExportWave: proc(wave: Wave, fileName: ^u8) => (bool)

@raylib #ExportWaveAsCode: proc(wave: Wave, fileName: ^u8) => (bool)

@raylib #PlaySound: proc(sound: Sound)

@raylib #StopSound: proc(sound: Sound)

@raylib #PauseSound: proc(sound: Sound)

@raylib #ResumeSound: proc(sound: Sound)

@raylib #PlaySoundMulti: proc(sound: Sound)

@raylib #StopSoundMulti: proc

@raylib #GetSoundsPlaying: proc => (s32)

@raylib #IsSoundPlaying: proc(sound: Sound) => (bool)

@raylib #SetSoundVolume: proc(sound: Sound, volume: f32)

@raylib #SetSoundPitch: proc(sound: Sound, pitch: f32)

@raylib #SetSoundPan: proc(sound: Sound, pan: f32)

@raylib #WaveCopy: proc(wave: Wave) => (Wave)

@raylib #WaveCrop: proc(wave: ^Wave, initSample: s32, finalSample: s32)

@raylib #WaveFormat: proc(wave: ^Wave, sampleRate: s32, sampleSize: s32, channels: s32)

@raylib #LoadWaveSamples: proc(wave: Wave) => (^f32)

@raylib #UnloadWaveSamples: proc(samples: ^f32)

@raylib #LoadMusicStream: proc(fileName: ^u8) => (Music)

@raylib #LoadMusicStreamFromMemory: proc(fileType: ^u8, data: ^u8, dataSize: s32) => (Music)

@raylib #UnloadMusicStream: proc(music: Music)

@raylib #PlayMusicStream: proc(music: Music)

@raylib #IsMusicStreamPlaying: proc(music: Music) => (bool)

@raylib #UpdateMusicStream: proc(music: Music)

@raylib #StopMusicStream: proc(music: Music)

@raylib #PauseMusicStream: proc(music: Music)

@raylib #ResumeMusicStream: proc(music: Music)

@raylib #SeekMusicStream: proc(music: Music, position: f32)

@raylib #SetMusicVolume: proc(music: Music, volume: f32)

@raylib #SetMusicPitch: proc(music: Music, pitch: f32)

@raylib #SetMusicPan: proc(music: Music, pan: f32)

@raylib #GetMusicTimeLength: proc(music: Music) => (f32)

@raylib #GetMusicTimePlayed: proc(music: Music) => (f32)

@raylib #LoadAudioStream: proc(sampleRate: u32, sampleSize: u32, channels: u32) => (AudioStream)

@raylib #UnloadAudioStream: proc(stream: AudioStream)

@raylib #UpdateAudioStream: proc(stream: AudioStream, data: ^u8, frameCount: s32)

@raylib #IsAudioStreamProcessed: proc(stream: AudioStream) => (bool)

@raylib #PlayAudioStream: proc(stream: AudioStream)

@raylib #PauseAudioStream: proc(stream: AudioStream)

@raylib #ResumeAudioStream: proc(stream: AudioStream)

@raylib #IsAudioStreamPlaying: proc(stream: AudioStream) => (bool)

@raylib #StopAudioStream: proc(stream: AudioStream)

@raylib #SetAudioStreamVolume: proc(stream: AudioStream, volume: f32)

@raylib #SetAudioStreamPitch: proc(stream: AudioStream, pitch: f32)

@raylib #SetAudioStreamPan: proc(stream: AudioStream, pan: f32)

@raylib #SetAudioStreamBufferSizeDefault: proc(size: s32)

@raylib #SetAudioStreamCallback: proc(stream: AudioStream, callback: AudioCallback)

@raylib #AttachAudioStreamProcessor: proc(stream: AudioStream, processor: AudioCallback)

@raylib #DetachAudioStreamProcessor: proc(stream: AudioStream, processor: AudioCallback)

