// OpenGL drawing backend

// hmm.. to easily allow for different backends, we would either need to implement module parameters + #if
// OR @using import().

#Array: import(":Array")
#Math: import(":Math")
#Map: import(":Map")
#Hash: import(":Hash")

#stbtt: import(":vendor/stb/stb_truetype")
#stbrp: import(":vendor/stb/stb_rect_pack")

#TEXTURE_SLOT: u32(0)
#VERTEX_BUFFER_CAPACITY: 32768
#INDEX_BUFFER_CAPACITY: 65536

#Vertex: struct {
	position: Vec2
	uv: Vec2
	enable_texture: f32
	color: Color
}

#Index: u32

#Canvas: struct {
	gl: ^GL.API
	//arena: ^Basic.Arena
	
	vertex_buf: []Vertex
	vertex_count: uint(0)
	
	index_buf: []Index
	index_count: uint(0)
	
	current_tex: ^Texture
	
	shader_program: GL.GLuint
	
	vbo: GL.GLuint
	ebo: GL.GLuint
	vao: GL.GLuint
}

#vertex_shader_src: "
#version 330

layout (location = 0) in vec2 a_position;
layout (location = 1) in vec2 a_uv;
layout (location = 2) in float a_enable_texture;
layout (location = 3) in vec4 a_color;

out vec4 vert_color;
out vec2 vert_uv;
out float vert_enable_texture;

void main() {
	vert_color = a_color;
	vert_uv = a_uv;
	vert_enable_texture = a_enable_texture;
	gl_Position = vec4(a_position, 0, 1.0);
}
"

#fragment_shader_src: "
#version 330

in vec4 vert_color;
in vec2 vert_uv;
in float vert_enable_texture;

out vec4 frag_color;

uniform sampler2D u_texture;

void main() {
	frag_color = vert_color * mix(vec4(1), texture(u_texture, vert_uv), vert_enable_texture);
}
"

#_check_gl_error: proc(gl: ^GL.API) {
	for, true, {
		err: gl.GetError()
		if err == GL.NO_ERROR {
			return
		}
		dbgbreak
	}
}

#compile_shader: proc(gl: ^GL.API, shader_type: GL.GLenum, src: ^u8) => GL.GLuint {
	shader: gl.CreateShader(shader_type)
	gl.ShaderSource(shader, 1, &src, ^GL.GLint(0))
	gl.CompileShader(shader)
	
	success: GL.GLint(0)
	gl.GetShaderiv(shader, GL.COMPILE_STATUS, &success)
	if success == 0 {
		vs_log: [512]GL.GLchar(~~)
		gl.GetShaderInfoLog(shader, 512, ^GL.GLsizei(0), &vs_log[0])
		dbgbreak
	}
	return shader
}

#init: proc(gl: ^GL.API, arena: ^Basic.Arena) => Canvas {
	vs: compile_shader(gl, GL.VERTEX_SHADER, vertex_shader_src.ptr)
	fs: compile_shader(gl, GL.FRAGMENT_SHADER, fragment_shader_src.ptr)
	
	// Link the shaders together into a shader program
	shader_program: gl.CreateProgram()
	gl.AttachShader(shader_program, vs)
	gl.AttachShader(shader_program, fs)
	gl.LinkProgram(shader_program)
	
	link_success: GL.GLint(0)
	gl.GetProgramiv(shader_program, GL.LINK_STATUS, &link_success)
	if link_success == 0 {
		log: [512]u8(~~)
		gl.GetProgramInfoLog(shader_program, 512, ^GL.GLsizei(0), &log[0])
		dbgbreak
	}
	
	// We can safely delete the shaders now that we have the shader program ready
	gl.DeleteShader(vs)
	gl.DeleteShader(fs)
	
	// Create the vertex array object
	vao: GL.GLuint(0)
	gl.GenVertexArrays(1, &vao)
	gl.BindVertexArray(vao)
	
	// Create the vertex buffer object
	vbo: GL.GLuint(0)
	gl.GenBuffers(1, &vbo)
	
	// Create the element buffer object
	ebo: GL.GLuint(0)
	gl.GenBuffers(1, &ebo)
	
	// Specify the vertex layout
	{
		gl.BindBuffer(GL.ARRAY_BUFFER, vbo)
		
		gl.VertexAttribPointer (0, 2, GL.FLOAT,        false, size_of(Vertex), ^raw(0))   // position
		gl.VertexAttribPointer (1, 2, GL.FLOAT,        false, size_of(Vertex), ^raw(8))   // uv
		gl.VertexAttribPointer (2, 1, GL.FLOAT,        false, size_of(Vertex), ^raw(16))  // enable_texture
		gl.VertexAttribPointer (3, 4, GL.UNSIGNED_BYTE, true, size_of(Vertex), ^raw(20))  // color
		gl.EnableVertexAttribArray(0)
		gl.EnableVertexAttribArray(1)
		gl.EnableVertexAttribArray(2)
		gl.EnableVertexAttribArray(3)
	}
	
	canvas: Canvas{
		gl: gl
		vertex_buf: Basic.make_slice_undef[Vertex](VERTEX_BUFFER_CAPACITY, arena)
		index_buf: Basic.make_slice_undef[Index](INDEX_BUFFER_CAPACITY, arena)
		shader_program: shader_program
		current_tex: ^Texture(0)
		vbo: vbo
		ebo: ebo
		vao: vao
	}
	
	return canvas
}

#deinit: proc(c: ^Canvas) {
	c.gl.DeleteBuffers(1, &c.ebo)
	c.gl.DeleteBuffers(1, &c.vbo)
	c.gl.DeleteVertexArrays(1, &c.vao)
	c.gl.DeleteProgram(c.shader_program)
}

#make_texture: proc(c: ^Canvas) => Texture {
	id: GL.GLuint(0)
	c.gl.GenTextures(1, &id)
	Basic.assert(id != 0) // maybe we shouldn't assert here...
	
	c.gl.ActiveTexture(GL.TEXTURE0 + TEXTURE_SLOT)
	c.gl.BindTexture(GL.TEXTURE_2D, id)
	c.gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.REPEAT)
	c.gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.REPEAT)
	c.gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR)
	c.gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR)
	return Texture{uint(id)}
}

#update_texture: proc(c: ^Canvas, texture: ^Texture, format: TextureFormat, width: u32, height: u32, data: ^raw) {
	Basic.assert(format == TextureFormat.RGBA8)
	
	c.gl.ActiveTexture(GL.TEXTURE0 + TEXTURE_SLOT)
	c.gl.BindTexture(GL.TEXTURE_2D, GL.GLuint(texture.backend_handle))
	c.gl.TexImage2D(GL.TEXTURE_2D, 0, GL.RGBA8, s32(width), s32(height), 0, GL.RGBA, GL.UNSIGNED_BYTE, data)
}

#make_texture_ex: proc(c: ^Canvas, format: TextureFormat, width: u32, height: u32, data: ^raw) => Texture {
	texture: make_texture(c)
	update_texture(c, &texture, format, width, height, data)
	return texture
}

#free_texture: proc(texture: ^Texture) {
	dbgbreak
}

#begin_drawing: proc(c: ^Canvas, background: Color) {
	c.vertex_count = 0
	c.index_count = 0
	
	gl: c.gl
	
	gl.Enable(GL.BLEND) // TODO: allow for customizable blend modes
	gl.BlendFunc(GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA)
	
	
		// Start off with a stencil buffer that is zeroed out. We want the fragment to pass the stencil test
		// when the stencil buffer has 1s. And we want to always flip the stencil buffer bits wherever we're drawing.
		// The process for drawing a concave polygon would look like:
		//  1. Draw the triangles with no alpha, as in https://medium.com/@evanwallace/easy-scalable-text-rendering-on-the-gpu-c3f4d782c5ac
		//  2. Draw a rectangle around the polygon with the desired color.
		//  3. IF revert_stencil is set, draw the rectangle and the triangles with no alpha, to revert the stencil buffer state.
		// Text rendering is most likely the bottleneck, so we want to optimize that.
		
		// gl.Enable(GL.STENCIL_TEST)
		// gl.StencilMask(0xFF)
		// gl.StencilFunc(GL.EQUAL, 0xFF, 0xFF)
		// gl.StencilOp(GL.INVERT, GL.INVERT, GL.INVERT)
	
	
	gl.ClearColor(f32(background.r) / 255., f32(background.g) / 255., f32(background.b) / 255., f32(background.a) / 255.)
	//gl.ClearStencil(0)
	//gl.Clear(bit_or(GL.COLOR_BUFFER_BIT, GL.STENCIL_BUFFER_BIT))
	gl.Clear(GL.COLOR_BUFFER_BIT)
	
	gl.UseProgram(c.shader_program)
	gl.BindVertexArray(c.vao)
	
	sampler_loc: gl.GetUniformLocation(c.shader_program, "u_texture".ptr)
	Basic.assert(sampler_loc != -1)
	gl.Uniform1i(sampler_loc, TEXTURE_SLOT) // NOTE: shader must be bound
	
	gl.BindBuffer(GL.ARRAY_BUFFER, c.vbo)
	gl.BindBuffer(GL.ELEMENT_ARRAY_BUFFER, c.ebo)
}

#end_drawing: proc(c: ^Canvas) {
	draw_and_flush_batch(c)
	_check_gl_error(c.gl)
}

// -- Primitive drawing procedures --

//#add_vertex: proc(c: ^Canvas, vert: Vertex) {
//	c.vertex_buf[c.vertex_count] = vert
//	c.vertex_count = .+1
//}

#draw_and_flush_batch: proc(c: ^Canvas) {
	if c.index_count > 0 {
		// TODO: use glBufferSubData or whatever, I think BufferData resizes the buffer?
		c.gl.BufferData(GL.ARRAY_BUFFER, s64(c.vertex_count * size_of(Vertex)), c.vertex_buf.ptr, GL.DYNAMIC_DRAW)
		c.gl.BufferData(GL.ELEMENT_ARRAY_BUFFER, s64(c.index_count * size_of(Index)), c.index_buf.ptr, GL.DYNAMIC_DRAW)
		
		// We could even trivially use 16-bit indices by limiting the index buffer batch size! That'd be pretty neat.
		c.gl.DrawElements(GL.TRIANGLES, s32(c.index_count), GL.UNSIGNED_INT, ^raw(0))
	}
	
	c.vertex_count = 0
	c.index_count = 0
}

#reserve_vertices: proc(c: ^Canvas, num_vertices: uint, num_indices: uint) => struct{v: u32, i: u32} {
	Basic.assert(num_vertices < c.vertex_buf.len)
	Basic.assert(num_indices < c.index_buf.len)
	
	if c.vertex_count + num_vertices > c.vertex_buf.len || c.index_count + num_indices > c.index_buf.len {
		// buffer is full, draw and flush
		draw_and_flush_batch(c)
	}
	
	v: u32(c.vertex_count), i: u32(c.index_count)
	c.vertex_count = .+ num_vertices
	c.index_count = .+ num_indices
	return {v, i}
}

#set_texture: proc(c: ^Canvas, texture: ^Texture(0)) {
	if c.current_tex != texture && texture != ^Texture(0) {
		if c.current_tex != ^Texture(0) {
			draw_and_flush_batch(c)
		}
		
		c.gl.ActiveTexture(GL.TEXTURE0 + TEXTURE_SLOT)
		c.gl.BindTexture(GL.TEXTURE_2D, GL.GLuint(texture.backend_handle))
	}
	c.current_tex = texture
}

#rect: proc(c: ^Canvas, r: Rect, color: Color, uv: DEFAULT_UV_RECT, texture: ^Texture(0)) {
	//apply_rect(c, r, Color{0, 0, 0, 0}, uv, texture) // fill stencil bits to 1
	apply_rect(c, r, color, uv, texture)
}

#polygon: proc(c: ^Canvas, points: []Vec2, color: Color) {
	apply_polygon(c, points, color)
	//apply_polygon(c, points, Color{0, 0, 0, 0}) // fill stencil bits to 1
	
	// find bounding box
	/*min_x: f32(1000000.)
	min_y: f32(1000000.)
	max_x: f32(-1000000.)
	max_y: f32(-1000000.)
	for i: 0, i<points.len, i=.+1 {
		p: points[i]
		min_x = Basic.max[f32](., p.x)
		min_y = Basic.max[f32](., p.y)
		max_x = Basic.min[f32](., p.x)
		max_y = Basic.min[f32](., p.y)
	}
	
	apply_rect(c, {min: {min_x, min_y}, max: {max_x, max_y}}, color)*/
}

#apply_rect: proc(c: ^Canvas, r: Rect, color: Color, uv: DEFAULT_UV_RECT, texture: ^Texture(0)) {
	set_texture(c, texture)
	base: reserve_vertices(c, num_vertices: 4, num_indices: 6)
	
	enable_texture: Basic.select[f32](texture == ^Texture(0), 0., 1.)
	
	c.vertex_buf[base.v]   = {r.min             , uv.min              , enable_texture, color}
	c.vertex_buf[base.v+1] = {{r.max.x, r.min.y}, {uv.max.x, uv.min.y}, enable_texture, color}
	c.vertex_buf[base.v+2] = {r.max             , uv.max              , enable_texture, color}
	c.vertex_buf[base.v+3] = {{r.min.x, r.max.y}, {uv.min.x, uv.max.y}, enable_texture, color}
	
	c.index_buf[base.i]    = base.v
	c.index_buf[base.i+1]  = base.v+1
	c.index_buf[base.i+2]  = base.v+2
	c.index_buf[base.i+3]  = base.v
	c.index_buf[base.i+4]  = base.v+2
	c.index_buf[base.i+5]  = base.v+3
}

#apply_polygon: proc(c: ^Canvas, points: []Vec2, color: Color) {
	// Draw a triangle from one of the points to all other points.
	// http://www.glprogramming.com/red/chapter14.html#name13
	
	Basic.assert(points.len >= 3)
	
	num_triangles: points.len - 2
	base: reserve_vertices(c, num_vertices: points.len, num_indices: num_triangles*3)
	
	for i: 0, i<points.len, i=.+1 {
		c.vertex_buf[base.v + u32(i)] = {points[i], {0., 0.}, 0., color}
	}
	
	// Use the last vertex as the "origin vertex" where all triangles are connected
	origin_vertex: base.v + u32(points.len) - 1
	
	for i: 0, i<num_triangles, i=.+1 {
		c.index_buf[base.i + u32(i)*3]     = origin_vertex
		c.index_buf[base.i + u32(i)*3 + 1] = base.v + u32(i)
		c.index_buf[base.i + u32(i)*3 + 2] = base.v + u32(i) + 1
	}
}








// -- Font stuff ------------------------------------------

#FontAtlasGlyphKey: struct {
	codepoint: rune
	font_id: u16
}

#FontAtlas: struct {
	arena: ^Basic.Arena
	fonts: Array.Array[^Font] // TODO: use a pool here
	glyphs: Map.Map[FontAtlasGlyphKey, FontAtlasGlyph]
}

#make_font_atlas: proc(arena: ^Basic.Arena) => ^FontAtlas {
	return Basic.new(FontAtlas{
		arena: arena
		fonts: Array.make[^Font](arena)
		glyphs: Map.make[FontAtlasGlyphKey, FontAtlasGlyph](arena)
	}, arena)
}

// #add_ttf_font_from_file: proc


#Font: struct {
	atlas: ^FontAtlas
	data: []u8
	size: f32
	y_offset: f32
}

#FontAtlasGlyph: struct {
	uv_origin: [2]f32
	size_pixels: [2]f32
	offset: [2]f32
	advance: f32
}

#add_ttf_font_from_data: proc(atlas: ^FontAtlas, data: []u8, size: f32, y_offset: f32) => ^Font {
	font: Basic.new(Font{atlas, data, size: size, y_offset: y_offset}, atlas.arena)
	Array.push(&atlas.fonts, font)
	return font
}

#rune: u32

#build_font_atlas: proc(atlas: ^FontAtlas) {
	arena: atlas.arena
	fonts: atlas.fonts
	
	// Padding between glyphs within texture in pixels.
	// If your rendering method doesn't rely on bilinear filtering you may set this to 0.
	glyph_padding: s32(1)
	
	total_surface: s32(0)
	
	#Range: struct{
		lo: u32
		hi: u32
	}
	
	codepoint_ranges: []Range{{33, 127}}
	
	#Glyph: struct {
		codepoint: rune
		font_id: u16
		glyph_index: s32
		w: s32, h: s32
	}
	
	glyphs: Array.make[Glyph](arena)
	font_info_per_font: Basic.make_slice_undef[stbtt.fontinfo](fonts.len, arena)
	glyph_range_per_font: Basic.make_slice_undef[Range](fonts.len, arena)
	
	oversample_h: s32(1)
	oversample_v: s32(1)
	
	for font_id: 0, font_id < fonts.len, font_id = .+1 {
		font: fonts[font_id] // ^Font
		font_info: &font_info_per_font[font_id] // ^stbtt.fontinfo
		
		glyph_range_per_font[font_id].lo = u32(glyphs.len)
		
		font_offset: stbtt.GetFontOffsetForIndex(font.data.ptr, 0)
		Basic.assert(font_offset >= 0)
		Basic.assert(stbtt.InitFont(font_info, font.data.ptr, font_offset) == 1)
		
		scale: stbtt.ScaleForPixelHeight(font_info, font.size)
		
		for range_i: 0, range_i < codepoint_ranges.len, range_i = .+1 {
			range: codepoint_ranges[range_i]
			
			for codepoint: range.lo, codepoint < range.hi, codepoint = .+1 {
				glyph_index: stbtt.FindGlyphIndex(font_info, s32(codepoint))
				
				x0: s32(~~), y0: s32(~~), x1: s32(~~), y1: s32(~~)
				stbtt.GetGlyphBitmapBoxSubpixel(font_info, glyph_index, scale * f32(oversample_h), scale * f32(oversample_v), 0., 0., &x0, &y0, &x1, &y1)
				
				width: x1 - x0 + glyph_padding + oversample_h - 1
				height: y1 - y0 + glyph_padding + oversample_v - 1
				Basic.assert(width >= 0)
				Basic.assert(height >= 0)
				total_surface = . + width * height
				
				Array.push(&glyphs, Glyph{
					codepoint: codepoint
					font_id: u16(font_id)
					glyph_index: glyph_index
					w: width
					h: height
				})
			}
		}
		
		glyph_range_per_font[font_id].hi = u32(glyphs.len)
	}
	
	surface_sqrt: Math.sqrtf(f32(total_surface)) + 1.0
	tex_width:
		Basic.select(surface_sqrt >= 4096., f32(4096. * 0.7),
		Basic.select(surface_sqrt >= 2048., f32(2048. * 0.7),
		Basic.select(surface_sqrt >= 1024., f32(1024. * 0.7), 512.)))
	
	tex_height_max: f32(1024.0 * 32.0)
	
	// Start packing the glyphs
	
	spc: stbtt.pack_context(~~)
	Basic.assert(stbtt.PackBegin(&spc, ^u8(0), s32(tex_width), s32(tex_height_max), 0, glyph_padding, ^raw(0)) == 1)
	
	buf_rects: Basic.make_slice_undef[stbrp.rect](glyphs.len, arena)
	glyph_list: Basic.make_slice_undef[u32](glyphs.len, arena)
	buf_packedchars: Basic.make_slice_undef[stbtt.packedchar](glyphs.len, arena)
	
	for i: 0, i < glyphs.len, i = .+1 {
		glyph: glyphs[i]
		Basic.assert(glyph.w >= 0)
		Basic.assert(glyph.h >= 0)
		buf_rects[i] = {
			w: glyph.w
			h: glyph.h
		}
		glyph_list[i] = glyph.codepoint
	}
	
	Basic.assert(stbrp.pack_rects(^stbrp.context(spc.pack_info), buf_rects.ptr, s32(buf_rects.len)) == 1)
	
	tex_height: s32(0)
	for i: 0, i < buf_rects.len, i = .+1 {
		r: buf_rects[i]
		tex_height = Basic.max(., r.y + r.h)
	}
	
	buffer_size: s32(tex_width) * tex_height
	texture_data: Basic.make_slice_undef[u8](uint(buffer_size), arena)
	Basic.memset(texture_data.ptr, 0, texture_data.len)
	
	spc.pixels = texture_data.ptr
	spc.height = tex_height
	
	for font_id: 0, font_id < atlas.fonts.len, font_id = .+1 {
		font: atlas.fonts[font_id] // ^Font
		glyph_range: glyph_range_per_font[font_id]

		pack_range: stbtt.pack_range {
			font_size:                         font.size,
			first_unicode_codepoint_in_range:  0,
			array_of_unicode_codepoints:       ^s32(&glyph_list[glyph_range.lo]),
			num_chars:                         s32(glyph_range.hi - glyph_range.lo),
			chardata_for_range:                &buf_packedchars[glyph_range.lo],
			h_oversample:                      u8(oversample_h),
			v_oversample:                      u8(oversample_v)
		}
		Basic.assert(stbtt.PackFontRangesRenderIntoRects(&spc, &font_info_per_font[font_id], &pack_range, 1, &buf_rects[glyph_range.lo]) == 1)
	}
	
	for i: 0, i < buf_rects.len, i = .+1 {
		stb_rect: buf_rects[i]
		glyph: glyphs[i]
		
		if (stb_rect.was_packed == 0) {
			Basic.assert(false) // Something was not packed when building the font atlas!
			continue
		}
		
		q: stbtt.aligned_quad(~~)
		unused_x: f32(0.), unused_y: f32(0.)
		stbtt.GetPackedQuad(buf_packedchars.ptr, s32(tex_width), tex_height, s32(i), &unused_x, &unused_y, &q, 0)
		
		font: atlas.fonts[glyph.font_id]
		font_info: font_info_per_font[glyph.font_id]
		
		val: FontAtlasGlyph {
			uv_origin:   {f32(stb_rect.x) / tex_width, f32(stb_rect.y) / f32(tex_height)}
			size_pixels: {f32(stb_rect.w), f32(stb_rect.h)}
			offset:      {q.x0, q.y0 + font.y_offset}
			advance:     buf_packedchars[i].xadvance
		}
		Map.add_assert_unique(&atlas.glyphs, FontAtlasGlyphKey{glyph.codepoint, glyph.font_id}, val)
	}
	
	dbgbreak
}


//#triangle: proc(c: ^Canvas, p1: Vec2, p2: Vec2, p3: Vec2, color: Color) {
//	first_vertex: Index(c.vertices.len)
//	
//	Array.push[Vertex](&c.vertices, {p1, uv: {0., 0.}, info: 0, scissor_rect: 0, color: color})
//	Array.push[Vertex](&c.vertices, {p2, uv: {0., 0.}, info: 0, scissor_rect: 0, color: color})
//	Array.push[Vertex](&c.vertices, {p3, uv: {0., 0.}, info: 0, scissor_rect: 0, color: color})
//	
//	Array.push[Index](&c.indices, first_vertex)
//	Array.push[Index](&c.indices, first_vertex + 1)
//	Array.push[Index](&c.indices, first_vertex + 2)
//}

