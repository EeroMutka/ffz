// OpenGL drawing backend

// hmm.. to easily allow for different backends, we would either need to implement module parameters + #if
// OR @using import().

#Array: import(":Array")

//#stbtt: import(":vendor/stb/stb_truetype")

#TEXTURE_SLOT: u32(0)
#VERTEX_BUFFER_CAPACITY: 32768
#INDEX_BUFFER_CAPACITY: 65536

#Vertex: struct {
	position: Vec2
	uv: Vec2
	enable_texture: f32
	color: Color
}

#Index: u32

#Canvas: struct {
	gl: ^GL.API
	//arena: ^Basic.Arena
	
	vertex_buf: []Vertex
	vertex_count: uint(0)
	
	index_buf: []Index
	index_count: uint(0)
	
	current_tex: ^Texture
	
	shader_program: GL.GLuint
	
	vbo: GL.GLuint
	ebo: GL.GLuint
	vao: GL.GLuint
}

#vertex_shader_src: "
#version 330

layout (location = 0) in vec2 a_position;
layout (location = 1) in vec2 a_uv;
layout (location = 2) in float a_enable_texture;
layout (location = 3) in vec4 a_color;

out vec4 vert_color;
out vec2 vert_uv;
out float vert_enable_texture;

void main() {
	vert_color = a_color;
	vert_uv = a_uv;
	vert_enable_texture = a_enable_texture;
	gl_Position = vec4(a_position, 0, 1.0);
}
"

#fragment_shader_src: "
#version 330

in vec4 vert_color;
in vec2 vert_uv;
in float vert_enable_texture;

out vec4 frag_color;

uniform sampler2D u_texture;

void main() {
	frag_color = vert_color * mix(vec4(1), texture(u_texture, vert_uv), vert_enable_texture);
}
"

#_check_gl_error: proc(gl: ^GL.API) {
	for, true, {
		err: gl.GetError()
		if err == GL.NO_ERROR {
			ret
		}
		dbgbreak
	}
}

#compile_shader: proc(gl: ^GL.API, shader_type: GL.GLenum, src: ^u8) => GL.GLuint {
	shader: gl.CreateShader(shader_type)
	gl.ShaderSource(shader, 1, &src, ^GL.GLint(0))
	gl.CompileShader(shader)
	
	success: GL.GLint(0)
	gl.GetShaderiv(shader, GL.COMPILE_STATUS, &success)
	if success == 0 {
		vs_log: [512]GL.GLchar(~~)
		gl.GetShaderInfoLog(shader, 512, ^GL.GLsizei(0), &vs_log[0])
		dbgbreak
	}
	ret shader
}

#init: proc(gl: ^GL.API, arena: ^Basic.Arena) => Canvas {
	alc: Basic.arena_alc(arena)
	
	vs: compile_shader(gl, GL.VERTEX_SHADER, vertex_shader_src.ptr)
	fs: compile_shader(gl, GL.FRAGMENT_SHADER, fragment_shader_src.ptr)
	
	// Link the shaders together into a shader program
	shader_program: gl.CreateProgram()
	gl.AttachShader(shader_program, vs)
	gl.AttachShader(shader_program, fs)
	gl.LinkProgram(shader_program)
	
	link_success: GL.GLint(0)
	gl.GetProgramiv(shader_program, GL.LINK_STATUS, &link_success)
	if link_success == 0 {
		log: [512]u8(~~)
		gl.GetProgramInfoLog(shader_program, 512, ^GL.GLsizei(0), &log[0])
		dbgbreak
	}
	
	// We can safely delete the shaders now that we have the shader program ready
	gl.DeleteShader(vs)
	gl.DeleteShader(fs)
	
	// Create the vertex array object
	vao: GL.GLuint(0)
	gl.GenVertexArrays(1, &vao)
	gl.BindVertexArray(vao)
	
	// Create the vertex buffer object
	vbo: GL.GLuint(0)
	gl.GenBuffers(1, &vbo)
	
	// Create the element buffer object
	ebo: GL.GLuint(0)
	gl.GenBuffers(1, &ebo)
	
	// Specify the vertex layout
	{
		gl.BindBuffer(GL.ARRAY_BUFFER, vbo)
		
		gl.VertexAttribPointer (0, 2, GL.FLOAT,        false, size_of(Vertex), ^raw(0))   // position
		gl.VertexAttribPointer (1, 2, GL.FLOAT,        false, size_of(Vertex), ^raw(8))   // uv
		gl.VertexAttribPointer (2, 1, GL.FLOAT,        false, size_of(Vertex), ^raw(16))  // enable_texture
		gl.VertexAttribPointer (3, 4, GL.UNSIGNED_BYTE, true, size_of(Vertex), ^raw(20))  // color
		gl.EnableVertexAttribArray(0)
		gl.EnableVertexAttribArray(1)
		gl.EnableVertexAttribArray(2)
		gl.EnableVertexAttribArray(3)
	}
	
	canvas: Canvas{
		gl: gl
		vertex_buf: Basic.make_slice_undef[Vertex](VERTEX_BUFFER_CAPACITY, alc)
		index_buf: Basic.make_slice_undef[Index](INDEX_BUFFER_CAPACITY, alc)
		shader_program: shader_program
		current_tex: ^Texture(0)
		vbo: vbo
		ebo: ebo
		vao: vao
	}
	
	ret canvas
}

#deinit: proc(c: ^Canvas) {
	c.gl.DeleteBuffers(1, &c.ebo)
	c.gl.DeleteBuffers(1, &c.vbo)
	c.gl.DeleteVertexArrays(1, &c.vao)
	c.gl.DeleteProgram(c.shader_program)
}

#make_texture: proc(c: ^Canvas) => Texture {
	id: GL.GLuint(0)
	c.gl.GenTextures(1, &id)
	Basic.assert(id != 0) // maybe we shouldn't assert here...
	
	c.gl.ActiveTexture(GL.TEXTURE0 + TEXTURE_SLOT)
	c.gl.BindTexture(GL.TEXTURE_2D, id)
	c.gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.REPEAT)
	c.gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.REPEAT)
	c.gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR)
	c.gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR)
	ret Texture{uint(id)}
}

#update_texture: proc(c: ^Canvas, texture: ^Texture, format: TextureFormat, width: u32, height: u32, data: ^raw) {
	Basic.assert(format == TextureFormat.RGBA8)
	
	c.gl.ActiveTexture(GL.TEXTURE0 + TEXTURE_SLOT)
	c.gl.BindTexture(GL.TEXTURE_2D, GL.GLuint(texture.backend_handle))
	c.gl.TexImage2D(GL.TEXTURE_2D, 0, GL.RGBA8, s32(width), s32(height), 0, GL.RGBA, GL.UNSIGNED_BYTE, data)
}

#make_texture_ex: proc(c: ^Canvas, format: TextureFormat, width: u32, height: u32, data: ^raw) => Texture {
	texture: make_texture(c)
	update_texture(c, &texture, format, width, height, data)
	ret texture
}

#free_texture: proc(texture: ^Texture) {
	dbgbreak
}

#begin_drawing: proc(c: ^Canvas, background: Color) {
	c.vertex_count = 0
	c.index_count = 0
	
	gl: c.gl
	
	gl.Enable(GL.BLEND) // TODO: allow for customizable blend modes
	gl.BlendFunc(GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA)
	
	
		// Start off with a stencil buffer that is zeroed out. We want the fragment to pass the stencil test
		// when the stencil buffer has 1s. And we want to always flip the stencil buffer bits wherever we're drawing.
		// The process for drawing a concave polygon would look like:
		//  1. Draw the triangles with no alpha, as in https://medium.com/@evanwallace/easy-scalable-text-rendering-on-the-gpu-c3f4d782c5ac
		//  2. Draw a rectangle around the polygon with the desired color.
		//  3. IF revert_stencil is set, draw the rectangle and the triangles with no alpha, to revert the stencil buffer state.
		// Text rendering is most likely the bottleneck, so we want to optimize that.
		
		// gl.Enable(GL.STENCIL_TEST)
		// gl.StencilMask(0xFF)
		// gl.StencilFunc(GL.EQUAL, 0xFF, 0xFF)
		// gl.StencilOp(GL.INVERT, GL.INVERT, GL.INVERT)
	
	
	gl.ClearColor(f32(background.r) / 255., f32(background.g) / 255., f32(background.b) / 255., f32(background.a) / 255.)
	//gl.ClearStencil(0)
	//gl.Clear(bit_or(GL.COLOR_BUFFER_BIT, GL.STENCIL_BUFFER_BIT))
	gl.Clear(GL.COLOR_BUFFER_BIT)
	
	gl.UseProgram(c.shader_program)
	gl.BindVertexArray(c.vao)
	
	sampler_loc: gl.GetUniformLocation(c.shader_program, "u_texture".ptr)
	Basic.assert(sampler_loc != -1)
	gl.Uniform1i(sampler_loc, TEXTURE_SLOT) // NOTE: shader must be bound
	
	gl.BindBuffer(GL.ARRAY_BUFFER, c.vbo)
	gl.BindBuffer(GL.ELEMENT_ARRAY_BUFFER, c.ebo)
}

#end_drawing: proc(c: ^Canvas) {
	draw_and_flush_batch(c)
	_check_gl_error(c.gl)
}

// -- Primitive drawing procedures --

//#add_vertex: proc(c: ^Canvas, vert: Vertex) {
//	c.vertex_buf[c.vertex_count] = vert
//	c.vertex_count = .+1
//}

#draw_and_flush_batch: proc(c: ^Canvas) {
	if c.index_count > 0 {
		// TODO: use glBufferSubData or whatever, I think BufferData resizes the buffer?
		c.gl.BufferData(GL.ARRAY_BUFFER, s64(c.vertex_count * size_of(Vertex)), c.vertex_buf.ptr, GL.DYNAMIC_DRAW)
		c.gl.BufferData(GL.ELEMENT_ARRAY_BUFFER, s64(c.index_count * size_of(Index)), c.index_buf.ptr, GL.DYNAMIC_DRAW)
		
		// We could even trivially use 16-bit indices by limiting the index buffer batch size! That'd be pretty neat.
		c.gl.DrawElements(GL.TRIANGLES, s32(c.index_count), GL.UNSIGNED_INT, ^raw(0))
	}
	
	c.vertex_count = 0
	c.index_count = 0
}

#reserve_vertices: proc(c: ^Canvas, num_vertices: uint, num_indices: uint) => struct{v: u32, i: u32} {
	Basic.assert(num_vertices < c.vertex_buf.len)
	Basic.assert(num_indices < c.index_buf.len)
	
	if c.vertex_count + num_vertices > c.vertex_buf.len || c.index_count + num_indices > c.index_buf.len {
		// buffer is full, draw and flush
		draw_and_flush_batch(c)
	}
	
	v: u32(c.vertex_count), i: u32(c.index_count)
	c.vertex_count = .+ num_vertices
	c.index_count = .+ num_indices
	ret {v, i}
}

#set_texture: proc(c: ^Canvas, texture: ^Texture(0)) {
	if c.current_tex != texture && texture != ^Texture(0) {
		if c.current_tex != ^Texture(0) {
			draw_and_flush_batch(c)
		}
		
		c.gl.ActiveTexture(GL.TEXTURE0 + TEXTURE_SLOT)
		c.gl.BindTexture(GL.TEXTURE_2D, GL.GLuint(texture.backend_handle))
	}
	c.current_tex = texture
}

#rect: proc(c: ^Canvas, r: Rect, color: Color, uv: DEFAULT_UV_RECT, texture: ^Texture(0)) {
	//apply_rect(c, r, Color{0, 0, 0, 0}, uv, texture) // fill stencil bits to 1
	apply_rect(c, r, color, uv, texture)
}

#polygon: proc(c: ^Canvas, points: []Vec2, color: Color) {
	apply_polygon(c, points, color)
	//apply_polygon(c, points, Color{0, 0, 0, 0}) // fill stencil bits to 1
	
	// find bounding box
	/*min_x: f32(1000000.)
	min_y: f32(1000000.)
	max_x: f32(-1000000.)
	max_y: f32(-1000000.)
	for i: 0, i<points.len, i=.+1 {
		p: points[i]
		min_x = Basic.max[f32](., p.x)
		min_y = Basic.max[f32](., p.y)
		max_x = Basic.min[f32](., p.x)
		max_y = Basic.min[f32](., p.y)
	}
	
	apply_rect(c, {min: {min_x, min_y}, max: {max_x, max_y}}, color)*/
}

#apply_rect: proc(c: ^Canvas, r: Rect, color: Color, uv: DEFAULT_UV_RECT, texture: ^Texture(0)) {
	set_texture(c, texture)
	base: reserve_vertices(c, num_vertices: 4, num_indices: 6)
	
	enable_texture: Basic.select[f32](texture == ^Texture(0), 0., 1.)
	
	c.vertex_buf[base.v]   = {r.min             , uv.min              , enable_texture, color}
	c.vertex_buf[base.v+1] = {{r.max.x, r.min.y}, {uv.max.x, uv.min.y}, enable_texture, color}
	c.vertex_buf[base.v+2] = {r.max             , uv.max              , enable_texture, color}
	c.vertex_buf[base.v+3] = {{r.min.x, r.max.y}, {uv.min.x, uv.max.y}, enable_texture, color}
	
	c.index_buf[base.i]    = base.v
	c.index_buf[base.i+1]  = base.v+1
	c.index_buf[base.i+2]  = base.v+2
	c.index_buf[base.i+3]  = base.v
	c.index_buf[base.i+4]  = base.v+2
	c.index_buf[base.i+5]  = base.v+3
}

#apply_polygon: proc(c: ^Canvas, points: []Vec2, color: Color) {
	// Draw a triangle from one of the points to all other points.
	// http://www.glprogramming.com/red/chapter14.html#name13
	
	Basic.assert(points.len >= 3)
	
	num_triangles: points.len - 2
	base: reserve_vertices(c, num_vertices: points.len, num_indices: num_triangles*3)
	
	for i: 0, i<points.len, i=.+1 {
		c.vertex_buf[base.v + u32(i)] = {points[i], {0., 0.}, 0., color}
	}
	
	// Use the last vertex as the "origin vertex" where all triangles are connected
	origin_vertex: base.v + u32(points.len) - 1
	
	for i: 0, i<num_triangles, i=.+1 {
		c.index_buf[base.i + u32(i)*3]     = origin_vertex
		c.index_buf[base.i + u32(i)*3 + 1] = base.v + u32(i)
		c.index_buf[base.i + u32(i)*3 + 2] = base.v + u32(i) + 1
	}
}

#rune: u32

#Font: struct {
	data: []u8
}

#build_font_atlas: proc(fonts: []Font) {
	
	// Padding between glyphs within texture in pixels.
	// If your rendering method doesn't rely on bilinear filtering you may set this to 0.
	/*glyph_padding: s32(1)
	
	total_surface: s32(0)
	
	#Range: struct {lo: u32, hi: u32}
	
	codepoint_ranges: []Range{{32, 127}}
	
	#Glyph: struct {
		codepoint: rune
		font_id: u16
		glyph_index: s32
		w: s32, h: s32
	}
	
	allocator: Basic.temp_alc() // TODO
	
	glyphs: Array.make[Glyph](allocator)
	font_infos: Basic.make_slice_undef[stbtt.fontinfo](fonts.len, allocator)
	glyph_ranges: Basic.make_slice_undef[Range](fonts.len, allocator)
	
	oversample_h: s32(1)
	oversample_v: s32(1)
	
	for font_id: 0, font_id < fonts.len, font_id = .+1 {
		font: &fonts[font_id] // ^Font
		font_info: &font_infos[font_id] // ^stbtt.fontinfo
		
		glyph_ranges[font_id].lo = glyphs.len
		
		font_offset: stbtt.GetFontOffsetForIndex(font.data.ptr, 0)
		Basic.assert(font_offset >= 0)
		Basic.assert(stbtt.InitFont(font_info, font.data.ptr, font_offset) == 1)
		
		scale: stbtt.ScaleForPixelHeight(font_info, font.size)
		
		{
		}
		
		glyph_ranges[font_id].hi = glyphs.len
	}*/
}


//#triangle: proc(c: ^Canvas, p1: Vec2, p2: Vec2, p3: Vec2, color: Color) {
//	first_vertex: Index(c.vertices.len)
//	
//	Array.push[Vertex](&c.vertices, {p1, uv: {0., 0.}, info: 0, scissor_rect: 0, color: color})
//	Array.push[Vertex](&c.vertices, {p2, uv: {0., 0.}, info: 0, scissor_rect: 0, color: color})
//	Array.push[Vertex](&c.vertices, {p3, uv: {0., 0.}, info: 0, scissor_rect: 0, color: color})
//	
//	Array.push[Index](&c.indices, first_vertex)
//	Array.push[Index](&c.indices, first_vertex + 1)
//	Array.push[Index](&c.indices, first_vertex + 2)
//}

