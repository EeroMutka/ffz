// hmm. I'm not sure if this should go inside the Basic module, as Basic/Array.
// I guess that depends on whether anything inside Basic requires an array implementation.

#Basic: import(":Basic")

// TODO: @alias_module_name

#Array: poly[T] struct {
	@using slice: []T{}
	capacity: uint(0)
	
	// We want to use an arena as the backing allocator for everything. This is because what we mean with an
	// "Arena" is broader than just a bump allocator. An Arena in our terms is a memory lifetime.
	// Dynamic array is not the best fit for a bump allocator, because the amount of memory required is effectively doubled,
	// as we're wasting memory on resize with the cost (1/2 + 1/4 + 1/8 + ...) which approaches 2.
	//
	// When you want to use a heap style memory allocations, you want to manually make a forwarder-arena that forwards
	// the allocations within that arena to the heap allocator. When we're doing that, we have a heap with "malloc" and "free" style
	// interface that is hidden away by the arena interface. To get around this and let the array inform that we'd like to
	// free/realloc, we could add a "arena_hint_free()" or "arena_realloc()"
	// Maybe in debug builds we could also just not even do that, and leave the old memory to 0xCC to make catching
	// bugs easier with regard to accidentally keeping pointer to array elements across array mutations.
	
	arena: ^Basic.Arena
}

#make: poly[T] proc(arena: ^Basic.Arena) => Array[T] {
	return Array[T]{arena: arena}
}

#clear: poly[T] proc(array: ^Array[T]) {
	array.len = 0
}

#push: poly[T] proc(array: ^Array[T], elem: T) {
	push_n_raw(^Array[raw](array), &elem, 1, size_of(T), align_of(T))
}

#push_n: poly[T] proc(array: ^Array[T], elems: []T) {
	push_n_raw(^Array[raw](array), elems.ptr, elems.len, size_of(T), align_of(T))
}

#insert: poly[T] proc(array: ^Array[T], at: uint, elem: T) {
	insert_n_raw(^Array[raw](array), at, &elem, 1, size_of(T), align_of(T))
}

#insert_n: poly[T] proc(array: ^Array[T], at: uint, elems: []T) {
	insert_n_raw(^Array[raw](array), at, elems.ptr, elems.len, size_of(T), align_of(T))
}

// --
// Raw array utilities - these are useful if you don't know the element type statically.
// --

#push_n_raw: proc(array: ^Array[raw], elems: ^raw, n: uint, elem_size: uint, elem_align: uint) {
	reserve_raw(array, array.len + n, elem_size, elem_align)
	
	Basic.memcpy(^raw(uint(array.ptr) + elem_size * array.len), elems, elem_size * n)
	
	array.len = .+n
}

#reserve_raw: proc(array: ^Array[raw], capacity: uint, elem_size: uint, elem_align: uint) {
	if (capacity > array.capacity) {
		// the + 7 is to make us start off with 8 elements initially
		new_capacity: Basic.round_up_to_power_of_2(capacity + 7)
		
		if (array.allocator == ^Basic.Allocator(0)) {
			dbgbreak // did you forget to call Array.make?
		}
		
		array.ptr = array.allocator._proc(array.allocator, array.ptr, array.capacity*elem_size, new_capacity*elem_size, elem_align)
		array.capacity = new_capacity
	}
}

#insert_n_raw: proc(array: ^Array[raw], at: uint, elem: ^raw, n: uint, elem_size: uint, elem_align: uint) {
	reserve_raw(array, array.len + n, elem_size, elem_align)
	
	// Move existing elements forward
	offset: uint(array.ptr) + at * elem_size
	Basic.memmove(^raw(offset + n * elem_size), ^raw(offset), (array.len - at) * elem_size)
	
	Basic.memcpy(^raw(offset), elem, n * elem_size)
	array.len = .+n
}
