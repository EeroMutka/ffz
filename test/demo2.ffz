//#B: import("../modules/basic")
//#Arr: import("../modules/Array")

// it'd be nice to be able to just have like a flag to the compiler here:
// @clang_debuginfo;

//\\link_library("hello", test= "hey")
//\\link_library("build/c_things.obj")

//@link_system_library: "" // link crt startup
/*
\build_options{
	true // clang_debuginfo
}

/* built-in */
#build_options: struct {
	clang_debuginfo: bool
}
#extern: struct{a: int}
@1 + 25*/



// Operator precedence, highest to lowest:
// () parenthesized expression
// .
// postfix []
// prefix ^, []
// postfix (), {}
// prefix -, +, &, !
// postfix ^
// *, /, %
// +, -
// <, <=, >, >=
// ==, !=
// &&
// ||

^foo()^ > !bar - 1
foo + 5 * bar > 2 * 5 + az

//^&Basic.Vector3 + aa.Bar.Baz^
//^Basic.Vector3[f32]{10, 2, 4}

/*

^u8(10)
^u8{100}
^u8[50]

	derived: ^NodeThing(node)

^Basic.Allocator[1]
// ^((Basic.Allocator)[1])

^Basic.Allocator(10)
// (^(Basic.Allocator))(10)

^Basic.Allocator{10}
// (^(Basic.Allocator)){10}

^Vector3[int] + 10



^u8(10)^ = 50

*/


/*
TODO: also parse the comments into the tree!
maybe comments that don't have an empty line after them should be tags.
Also, if there is a node in the same line before the comment, it could be a tag to the node.
*/
#foo: string

//hello, sailor!

// testing

// I suppose we should typecheck the tags too
// A tag is just a constant value.
// but the metaprogram needs to classify the tags, there needs to be a way to know whose tag something is.
// So maybe a tag must be a struct literal.
#Vector3: struct{a: int, b: int, z: int}

\Vector3{1, 2, 4}
#main: proc() {
	
	if f: read_file() {
		test
	}
	
	dbgbreak
	
	/*print_string("--------")
	
	print_string("Hello, world!", "okay?")
	
	foo: [3]uint{1, 2, 4}
	foo[0] = 201
	
	print_uint(foo[0])
	print_uint(foo[1])
	print_uint(foo[2])
	
	print_string("Done!")*/
	
/*	
	
	//str: "Hello, sailor!".ptr
	
	//for i: 0, i<3, i=.+1 {
	//	result = . * 5
	//	test(result)
	//	//B.f_os_print_color("hoi ", B.fConsoleAttributeFlags(B.fConsoleAttribute.Green))
	//}
	/*
	
	*/
	//adder[int](1, 2)
	//adder_int(50, 60)
*/	
}

/*

Idea: hierarchical enum types.
OR allow arbitrary boolean expressions in switch statements. Or both!

#OperatorKind: enum {
	add,
	mul,
	div,
}
	
#NodeKind: enum {
	Declare,
	Literal,
	@using OperatorKind,
}

switch (node.kind) {
	OperatorKind = {
	}
}

*/
