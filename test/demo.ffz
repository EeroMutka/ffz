#Basic: import(":Basic")


#Window: import(":Window")
#GL: import(":OpenGL")
#Draw2D: import(":Draw2D/OpenGL")

#Files: import(":Files")
#stbi: import(":vendor/stb/stb_image")

#Globals: struct {
	window: Window.Window
	gl: GL.API
	canvas: Draw2D.Canvas
}

@*global
g: Globals(~~)

#draw: proc {
	Draw2D.clear_lists(&g.canvas)
	
	Draw2D.triangle(&g.canvas, {-0.5, -0.5}, {0.5, -0.5}, {0., 0.5}, color: {20, 102, 222, 255})
	Draw2D.rect(&g.canvas, {{-0.1, -0.1}, {0., 0.}}, color: {255, 102, 222, 255})
	
	Draw2D.draw_to_backend(&g.canvas, background: {20, 40, 20, 255})
	
	if !GL.swap_buffers(g.window) {dbgbreak}
}

#resize_cb: Window.ResizeCallback {
	g.gl.Viewport(0, 0, s32(in.width), s32(in.height))
	draw()
}

#entry: proc {
	Basic.print("hello!\n")
	g.window = Window.create(512, 512, "My window")
	
	gl: &g.gl
	GL.load(gl, g.window, GL.Version._3_3)
	
	g.canvas = Draw2D.init(gl, Basic.temp_arena())
	
	
	// load images
	// we need a read-entire-file procedure
	image_file: Files.read_entire_file("C:/Users/Eero/Pictures/MURS.png", Basic.temp_alc())
	Basic.assert(image_file.ok)
	
	
	width: s32(~~), height: s32(~~), channels_in_file: s32(~~)
	
	stbi.set_flip_vertically_on_load(1)
	img_data: stbi.load_from_memory(image_file.data.ptr, s32(image_file.data.len),
		&width, &height, &channels_in_file, desired_channels: 4)
	
	if img_data == ^u8(0) {
		dbgbreak
	}
	
	texture: GL.GLuint(0)
	gl.GenTextures(1, &texture)
	gl.BindTexture(GL.TEXTURE_2D, texture)
	gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.REPEAT)
	gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.REPEAT)
	gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR)
	gl.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR)

	gl.TexImage2D(GL.TEXTURE_2D, 0, GL.RGBA8, width, height, 0, GL.RGBA, GL.UNSIGNED_BYTE, img_data)
	
	// stbi.image_free(img_data)
	
	{ // set active texture
		// learnopengl.com says there should be always at least 16 texture slots available to use.
		
		gl.ActiveTexture(GL.TEXTURE0)
		gl.BindTexture(GL.TEXTURE_2D, texture)
		
		gl.UseProgram(g.canvas.shader_program) // shader must be bound for setting uniforms
		sampler_loc: gl.GetUniformLocation(g.canvas.shader_program, "my_sampler".ptr)
		if sampler_loc == -1 { dbgbreak }
		gl.Uniform1i(sampler_loc, 0)
	}
	
	Window.show(g.window)
	
	i: 0
	
	quit: false
	for, !quit {
		events: Window.poll_events(g.window, resize_cb, ^raw(gl))
		
		if events.quit {
			quit = true
		}
		
		if !quit {
			draw()
		}
		
		i= . + 1
	}
}
