
#Basic: import(":Basic")
#Array: import(":Array")
#RL: import(":vendor/raylib")

#V2: [2]int

#window_size: uint(512)
#grid_size: uint(32)

#v2_eq: proc(a: V2, b: V2) => bool {
	ret a.x == b.x && a.y == b.y
}

#v2_add: proc(a: V2, b: V2) => V2 {
	ret V2{a.x + b.x, a.y + b.y}
}

#random_grid_slot: proc() => V2 {
	ret V2{
		int(RL.GetRandomValue(0, s32(grid_size-1)))
		int(RL.GetRandomValue(0, s32(grid_size-1)))
	}
}

#Game: struct {
	snake: Array.Array[V2]
	
	apple_pos: V2{2, 2}
	
	lost: false
	
	snake_direction: V2{1, 0}
	
	score: uint(0)
	
	ticker: int(0)
}

#update: proc(game: ^Game) {
	snake: &game.snake
	if game.lost {
		ret
	}
	
	input: V2{0, 0}
	if RL.IsKeyPressed(RL.KeyboardKey.RIGHT) && game.snake_direction.x == 0 {
		input = V2{1, 0}
	}
	if RL.IsKeyPressed(RL.KeyboardKey.LEFT) && game.snake_direction.x == 0 {
		input = V2{-1, 0}
	}
	if RL.IsKeyPressed(RL.KeyboardKey.UP) && game.snake_direction.y == 0 {
		input = V2{0, -1}
	}
	if RL.IsKeyPressed(RL.KeyboardKey.DOWN) && game.snake_direction.y == 0 {
		input = V2{0, 1}
	}
	
	if !v2_eq(input, V2{0, 0}) && !v2_eq(input, game.snake_direction) {
		game.ticker = 0 // instant feedback
	}
	
	if game.ticker <= 0 {
		game.ticker = 8
		
		if !v2_eq(input, V2{0, 0}) {
			game.snake_direction = input
		}
		
		
		// eat the apple if the head is at the apple
		eat_apple: v2_eq(snake^[0], game.apple_pos)
		if eat_apple {
			Array.insert[V2](snake, 0, snake^[0])
			game.score = .+1
		}
		else {
			// move all segments (except the head) towards the head
			for i: int(snake.len) - 1, i > 0, i= .-1 {
				if !v2_eq(snake^[i], snake^[i-1]) {
					snake^[i] = snake^[i-1]
				}
			}
		}
		
		snake^[0] = v2_add(., game.snake_direction) // move the head forward
		head: snake^[0]
		
		
		
		if head.x < 0 || head.x >= grid_size || head.y < 0 || head.y >= grid_size {
			game.lost = true
		}
		
		if eat_apple {
			// Move the apple to a random grid slot that does not overlap with the snake
			
			for apple_pos_ok: false, !apple_pos_ok, {
				game.apple_pos = random_grid_slot()
				apple_pos_ok = true
				
				for i: 1, i < snake.len, i= .+1 {
					if v2_eq(game.apple_pos, snake^[i]) {
						apple_pos_ok = false
					}
				}
			}
		}
		
		// if you hit yourself, lose
		for i: 1, i < snake.len, i= .+1 {
			if v2_eq(head, snake^[i]) {
				dbgbreak
				game.lost = true
			}
		}
	}
	
	game.ticker= . - 1
}

#draw: proc(game: ^Game) {
	RL.BeginDrawing()
	
	rect_width: window_size / grid_size
	
	RL.ClearBackground(RL.Color{200, 200, 200, 255})
	
	for y: 0, y < grid_size, y= y + 1 {
		for x: 0, x < grid_size, x= x + 1 {
			RL.DrawRectangle(
				s32(x * rect_width)
				s32(y * rect_width)
				s32(rect_width - 2)
				s32(rect_width - 2)
				RL.Color{190, 190, 190, 255})
		}
	}
		
	// draw apple
	RL.DrawRectangle(
		s32(game.apple_pos.x * rect_width)
		s32(game.apple_pos.y * rect_width)
		s32(rect_width-2)
		s32(rect_width-2)
		RL.Color{240, 250, 100, 255})
	
	// draw snake
	for i: 0, i < game.snake.len, i= .+1 {
		coord: game.snake[i]
		RL.DrawRectangle(
			s32(coord.x * rect_width)
			s32(coord.y * rect_width)
			s32(rect_width-2)
			s32(rect_width-2)
			RL.Color{200, 20, 255, 255})
	}
	
	if game.lost {
		RL.DrawText("GAME LOST!\0".ptr, 190, 5, 30, RL.Color{255, 0, 0, 220})
	}
	
	RL.EndDrawing()
}

#entry: proc() {
	// init raylib
	RL.InitWindow(s32(window_size), s32(window_size), "Hello".ptr)
	
	RL.SetRandomSeed(100)
	
	game: Game{
		snake: Array.make[V2](Basic.temp_alc())
	}
	
	Array.push[V2](&game.snake, V2{5, 5})
	
	RL.SetTargetFPS(60)
	
	// main loop
	for, !RL.WindowShouldClose() {
		update(&game)
		draw(&game)
	}
}